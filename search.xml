<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言多线程编程 (二)</title>
    <url>/2023/11/28/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/</url>
    <content><![CDATA[<p>C语言实现线程的之间的同步和互斥，通过临界区、互斥量、事件、信号量实现线程的同步互斥，同时讲解一下进程之间的同步互斥。</p>
<span id="more"></span>
<h1>临界区实现同步互斥</h1>
<ol>
<li>
<p>首先我们要声明一个临界区的变量，利用临界区变量来实现临界区。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION global_cirtical_sectioin;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用临界区变量需要先初始临界区变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>进入临界区，利用临界区变量上锁。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>出临界区，解锁。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用结束后，删除临界变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完成的使用流程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION global_cirtical_sectioin;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> WINAPI <span class="title">thread_task</span><span class="params">(LPVOID paramter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;global_thread_parameter);</span><br><span class="line">	<span class="comment">// 临界区代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 出临界区   </span></span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;global_thread_parameter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_zone_synchronization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hThread[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 初始化临界区变量</span></span><br><span class="line">	<span class="built_in">InitializeCriticalSection</span>(&amp;global_thread_code);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		hThread[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, thread_task, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">5</span>, hThread, TRUE, INFINITE);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hThread[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DeleteCriticalSection</span>(&amp;global_thread_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的临界区的设置，只允许同一时间只有一个线程能够执行临界区代码。</p>
<h1>互斥量实现同步互斥</h1>
<p>大致步骤和临界区相同。</p>
<ol>
<li>
<p>初始化互斥量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE mutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><code>CreateMutex</code>的作用是找出当前系统是否存在指定进程的示例，如果没有则创建一个互斥体。</p>
<ul>
<li>互斥对象是系统内核维护的一种数据结构，保证对象对单个线程的访问权。</li>
<li>互斥对象结构包括：使用数量（多少个线程调用该对象），线程ID（互斥对象的维护线程ID），计数器（当前线程调用该对象的次数）。</li>
<li>参数说明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateMutexA</span>(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, <span class="comment">// 指向安全属性的指针</span></span><br><span class="line">    _In_ BOOL bInitialOwner, <span class="comment">// 初始化互斥对象的所有者 如果为 TRUE 表示互斥量为创建线程所有</span></span><br><span class="line">    _In_opt_ LPCSTR lpName <span class="comment">// 指向互斥对象名的指针</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待互斥量被触发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(mutex, INFINITE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发互斥量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReleaseMutex</span>(mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销互斥量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(mutex);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>事件实现同步互斥</h1>
<ol>
<li>
<p>初始化事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE event = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes, 	<span class="comment">// 安全属性结构体指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bManualReset,      	<span class="comment">// 是否手动复位</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInitialState,    	<span class="comment">// 初始状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR               lpName             	<span class="comment">// 事件名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lpEventAttributes</code>：一个指向SECURITY_ATTRIBUTES结构体的指针，用于设置事件对象的安全属性。如果该参数为NULL，则事件对象会继承调用进程的安全属性。</li>
<li><code>bManualReset</code>：一个布尔值，用于指定事件对象的类型。如果该参数为TRUE，则表示创建的是手动复位事件对象；如果该参数为FALSE，则表示创建的是自动复位事件对象。手动复位事件对象必须通过调用<code>ResetEvent</code>函数来将事件状态复位（即重置为未激发状态）；而自动复位事件对象则会在有信号触发时自动将其状态复位。</li>
<li><code>bInitialState</code>：一个布尔值，用于指定事件对象的初始状态。如果该参数为TRUE，则表示在创建事件对象时立即将其设置为已激发状态（signaled）；如果该参数为FALSE，则表示事件对象初始状态为未激发状态（nonsignaled）。</li>
<li><code>lpName</code>：一个字符串指针，用于指定事件对象的名称。如果该参数为NULL，则表示创建一个无名事件对象；否则表示创建命名的事件对象。需要注意的是，如果同时存在同名的命名事件对象，则会返回该事件对象的句柄。</li>
</ul>
</li>
<li>
<p>等待事件发生</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(event, INFINITE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SetEvent</span>(event);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(event);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>信号量同步</h1>
<ol>
<li>
<p>初始化信号量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前0个资源、最大允许1个同时访问</span></span><br><span class="line">HANDLE semaphore = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待$信号量&gt;1$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(semaphore, INFINITE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>释放一个资源，信号量加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReleaseSemaphore</span>(semaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销信号量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(semaphore);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>进程之间互斥信号量实现互斥</h1>
<p>和线程之间原理一样，这里多了一步需要打开互斥对象，互斥对象有操作内核管理，通过名称查找到。</p>
<p>互斥对象存在时，同名的进程时不能运行的。</p>
<ol>
<li>
<p>创建互斥量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, TRUE, MUTEX_NAME);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打开互斥量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hMutex = <span class="built_in">OpenMutex</span>(MUTEX_ALL_ACCESS, TRUE, MUTEX_NAME);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发互斥量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待互斥量触发</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>存在问题</h1>
<h2 id="WaitForSingleObject">WaitForSingleObject()</h2>
<p><code>WaitForSingleObject</code>函数的执行流程如下：</p>
<ol>
<li>线程调用<code>WaitForSingleObject</code>函数并传入需要等待的对象的句柄以及等待时间的长度。</li>
<li>系统检查对象的当前状态：
<ul>
<li>如果对象已经是 signaled 状态（已激发），则直接返回<code>WAIT_OBJECT_0</code>，线程可以继续执行后续操作。</li>
<li>如果对象不是 signaled 状态（未激发），则线程进入等待状态，并将该线程从可执行状态转换为等待状态，直到以下三种情况之一发生：
<ul>
<li>对象被激发，即对象状态变为 signaled。此时，线程会被唤醒，并返回<code>WAIT_OBJECT_0</code>，线程可以继续执行后续操作。</li>
<li>等待超时，即指定的等待时间到达。此时，线程会被唤醒，并返回<code>WAIT_TIMEOUT</code>，线程可以根据需要进行相应处理。</li>
<li>等待的对象被放弃。这通常出现在使用互斥体时，当互斥体的所有者线程意外终止而没有正确释放互斥体时，其他线程在等待该互斥体时会返回<code>WAIT_ABANDONED</code>。</li>
</ul>
</li>
</ul>
</li>
<li>线程根据返回值进行相应的处理。</li>
</ol>
<h2 id="不同线程之间临界区和互斥量不起作用">不同线程之间临界区和互斥量不起作用</h2>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>同步互斥</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言多线程编程 (一)</title>
    <url>/2023/11/25/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/</url>
    <content><![CDATA[<p>简单说明和使用C语言在window操作系统下创建多线程实现简单的示例操作。</p>
<span id="more"></span>
<h2 id="创建进程">创建进程</h2>
<p>使用的是<code>windows.h</code>提供的创建进程函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_caculator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwExitCode;</span><br><span class="line">	PROCESS_INFORMATION	pi;</span><br><span class="line">	DWORD ret;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="built_in">sizeof</span>(si) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;calc.exe&quot;</span>;</span><br><span class="line">	<span class="comment">// 启动计算机</span></span><br><span class="line">	<span class="comment">// C++不能字符串转换 修改工程属性 项目属性-&gt;高级-&gt;字符集-&gt;使用Unicode字符集改为未设置</span></span><br><span class="line">	ret = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, s, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="comment">// 等待子进程的退出</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);</span><br><span class="line">		<span class="comment">// 关闭子进程的主线程语句</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">		<span class="comment">// 获取子进程的退出码</span></span><br><span class="line">		<span class="built_in">GetExitCodeProcess</span>(pi.hProcess, &amp;dwExitCode);</span><br><span class="line">		<span class="comment">// 关闭子进程句柄</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n进程结束 退出码是&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要的是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, s, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>lpApplicationName: 指定要运行的可执行文件的名称。在这种情况下，使用NULL表示使用命令行参数中指定的可执行文件</li>
<li><strong>lpCommandLine: 指定要传递给可执行文件的命令行参数。在这种情况下，使用字符串变量s作为命令行参数。</strong></li>
<li>lpProcessAttributes: 指定新进程的安全描述符。在这种情况下，使用NULL表示使用默认的安全描述符。</li>
<li>lpThreadAttributes: 指定新线程的安全描述符。在这种情况下，使用NULL表示使用默认的安全描述符。</li>
<li>bInheritHandles: 指定是否继承父进程的句柄。在这种情况下，使用FALSE表示不继承句柄。</li>
<li>dwCreationFlags: 指定控制新进程创建方式的标志。在这种情况下，使用0表示默认创建方式。</li>
<li>lpEnvironment: 指定新进程的环境块。在这种情况下，使用NULL表示使用父进程的环境块。</li>
<li>lpCurrentDirectory: 指定新进程的当前工作目录。在这种情况下，使用NULL表示使用父进程的当前工作目录。</li>
<li><strong>lpStartupInfo: 指向一个STARTUPINFO结构，该结构包含了新进程的一些属性，例如窗口显示方式、标准输入输出重定向等。在这种情况下，使用si结构体。</strong></li>
<li><strong>lpProcessInformation: 指向一个PROCESS_INFORMATION结构，该结构接收新进程的标识信息，例如进程句柄和线程句柄。在这种情况下，使用pi结构体。</strong></li>
</ul>
<p>这里运行会打开计算机，当时主进程会直接结束，计算器仍保留。</p>
<blockquote>
<p>疑问：这里主进程是等待子进程结束才会结束，而这个子进程是计算器本身这个进程，还是只开启计算器的进程？</p>
<p>个人理解是：IpCommandLine是传递命令参数，可能我们自己开启的进程的任务只是开启进程而不是计算器运行本身这个进程。</p>
</blockquote>
<h2 id="创建线程">创建线程</h2>
<p>定义线程结构体和启动线程两部分最重要。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hTread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, create_thread_task1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>线程使用的是<code>&lt;process.h&gt;</code>头文件。</p>
<p>第三个参数是传递线程执行函数的函数指针。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> WINAPI <span class="title">create_thread_task1</span><span class="params">(LPVOID paramter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;child thread running ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread_example_run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 句柄声明定义</span></span><br><span class="line">	<span class="comment">// _beginthreadex()函数创建一个新的线程 指定子线程执行函数指针(函数类型固定) 返回线程的句柄</span></span><br><span class="line">	HANDLE hTread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, create_thread_task1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;main thread running ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 句柄可以访问线程中各种系统资源 标识对象 访问对象 资源管理</span></span><br><span class="line">	<span class="comment">// 通过CloseHandle函数关闭线程句柄 释放资源</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hTread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里线程执行的函数是固定的定义方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> WINAPI <span class="title">xxx</span><span class="params">(LPVOID paramter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LPVOID paramter</code>：可以接收参数，通过创建线程执行语句的第4个参数</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;参数<span class="number">1</span>：指定线程安全特性 null 表示使用默认的安全特性</span><br><span class="line">&gt;参数<span class="number">2</span>：指定线程的堆栈大小 通常设置为<span class="number">0</span> 表示使用默认堆栈大小</span><br><span class="line">&gt;参数<span class="number">3</span>：指向线程函数的指针</span><br><span class="line">&gt;参数<span class="number">4</span>：传递给线程函数的参数 可以是任意类型的指针 接收是 <span class="type">void</span>* 类型</span><br><span class="line">&gt;参数<span class="number">5</span>：指定线程初始化标志 通常设置为<span class="number">0</span></span><br><span class="line">&gt;参数<span class="number">6</span>：用于接收新线程的标识符</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="线程其他相关命令">线程其他相关命令</h2>
<ul>
<li>主线程等待子线程结束语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前线程的ID</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetCurrentThreadId</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>对于多个线程的处理，需要依次关闭线程，示例代码如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_multi_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE handles[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 依次开启多个线程</span></span><br><span class="line">		handles[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, thread_task3, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">10</span>, handles, TRUE, INFINITE);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main thread ending ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 依次关闭多个线程</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(handles[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主线程等待所有子线程结束</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForMultipleObjects</span>(<span class="number">3</span>, handles, TRUE, INFINITE);</span><br></pre></td></tr></table></figure>
<h2 id="补充知识">补充知识</h2>
<p>函数指针和函数指针数组，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task21</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"># 函数指针数组</span><br><span class="line"><span class="built_in">void</span> (*tasks[<span class="number">3</span>])() = &#123; thread_task1, thread_task2, thread_task3 &#125;;</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">tasks[i]();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建</title>
    <url>/2023/11/25/create_blog/</url>
    <content><![CDATA[<p>主要介绍一个初始博客的搭建和简单next主题的配置和遇到的问题，采用git + github + hexo + hexo next主题实现的一个个人博客网站。</p>
<span id="more"></span>
<h2 id="工具准备">工具准备</h2>
<p>下载git，参考网址：<a href="https://juejin.cn/post/7086817870172782623">图文详解 Git 安装【当前最新，最详细版】 - 掘金 (juejin.cn)</a></p>
<p>下载node.js，参考网址：<a href="https://juejin.cn/post/7090056744549744676">node.js安装及环境配置 - 掘金 (juejin.cn)</a></p>
<p>然后打开git bash命令窗口输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="github创建仓库">github创建仓库</h3>
<ol>
<li>
<p>自己注册一个账号，开始创建仓库，可以参考<a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p>需要注意的是仓库名称<code>xxx.github.io</code>。</p>
</li>
<li>
<p>在git上配置远程连接SSH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -global user.name &quot;用户名&quot;</span><br><span class="line">git config -global user.email &quot;邮箱&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成SSH密钥</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>生成结果：</p>
<p>路径<code>C:\Users\电脑用户名\.ssh\id_rsa.pub</code></p>
<p><img src="/2023/11/25/create_blog/image-20231125201927788.png" alt="image-20231125201927788"></p>
<p><img src="/2023/11/25/create_blog/image-20231125202103556.png" alt="image-20231125202103556"></p>
</li>
<li>
<p>将密钥全部复制粘贴到GitHub上</p>
<p><img src="/2023/11/25/create_blog/image-20231125202323393.png" alt="image-20231125202323393"></p>
</li>
</ol>
<h2 id="初始hexo项目">初始hexo项目</h2>
<h3 id="初始创建">初始创建</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure>
<p>下载next主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:theme-next/hexo-theme-next.git  ./themes/next</span><br></pre></td></tr></table></figure>
<p>更改根目录下的<code>_config.yml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">themes:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>然后执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取仓库内容</span></span><br><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译运行 本地测试</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载hexo-devloper</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>将根目录下<code>.config.yml</code>配置文件修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="comment"># https://xxx.github.io</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># https://gitee.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>配置修改后执行：（一定要先修改配置文件后在进行提交）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>执行上述所有步骤后，就可以通过github看到一个初始状态的个人博客了。</p>
<h2 id="Next主题配置">Next主题配置</h2>
<h3 id="选择主题">选择主题</h3>
<p>主题配置文件下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>可以自行选择四种样式。</p>
<h3 id="修改博客头像">修改博客头像</h3>
<p>在<code>themes/next/source/images</code>放入设置的图片。</p>
<img src="/2023/11/25/create_blog/image-20231125150218977.png" alt="image-20231125150218977">
<p>在主题配置文件中设置路径即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="侧边栏社交添加">侧边栏社交添加</h3>
<p>主题配置文件夹下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com || fab fa-github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure>
<h3 id="添加菜单结构">添加菜单结构</h3>
<p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>这样就可以创建一个tags目录，效果如图所示：</p>
<p><img src="/2023/11/25/create_blog/image-20231125135239747.png" alt="image-20231125135239747"></p>
<p>同理还可以创建<code>about、categories、archives</code>等菜单文件。</p>
<p>我们需要进入到每个文件目录下面去修改它<code>index.md</code>文件，修改它的类型，如图所示：</p>
<p><img src="/2023/11/25/create_blog/image-20231125135911341.png" alt="image-20231125135911341"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">tags: tags</span><br><span class="line">categories: categories</span><br><span class="line">留言板: 将comments一栏改为true type改为guestbook</span><br></pre></td></tr></table></figure>
<p>在主题的配置文件<code>_config.yml</code>开启对应菜单：</p>
<p><img src="/2023/11/25/create_blog/image-20231125140353312.png" alt="image-20231125140353312"></p>
<p>可以设置显示数量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="添加搜索功能">添加搜索功能</h3>
<p>下载搜索插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>主题目录下配置文件<code>_config.yml</code>开启本地搜索：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>根目录下<code>_config.yml</code>配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="添加动态背景">添加动态背景</h3>
<p>打开生成的hexo目录<code>\themes\next\layout\_layout.swig</code>文件，将代码放在<code>&lt;/body&gt;</code>上面。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% if theme.canvas_nest %&#125;</span></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;<span class="comment">% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>主题配置文件添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># background settings</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># add canvas-nest effect</span></span><br><span class="line"><span class="comment"># see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="增加阅读时间和文章数字统计">增加阅读时间和文章数字统计</h3>
<p>下载插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>
<p>根目录下配置文件添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span>    </span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>
<p>主题配置文件下打开开关：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="部件配置">部件配置</h3>
<p>都在主题配置文件下</p>
<p>阅读进度条：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure>
<p>左上角Github图标：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/xxx</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>
<p>开启代码复制：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure>
<p>文末尾版权说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>
<p>设置回到顶部</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># Back to top in sidebar.</span></span><br><span class="line"> <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line"> <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"> <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="问题">问题</h2>
<h3 id="图片不显示">图片不显示</h3>
<p>hexo生成后图片路劲发生改变，导致了生成后文章找不到图片。</p>
<p>下载插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>修改根目录下配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>生成的时候可能要等一会，多刷新几次。</p>
<p>只有md文档同级下有对应文件夹来放图片就可以了。</p>
<p>如果还是不行，直接去修改<code>hexo-asset-image</code>包下的<code>index.js</code>文件：</p>
<p><img src="/2023/11/25/create_blog/image-20231125182910235.png" alt="image-20231125182910235"></p>
<p>去调整<code>index.js</code>的中路径字符串拼接的部分，视自己当前问题来合理调整。</p>
<p><strong>这里还需要注意的是根目录下的配置文件中<code>url</code>的配置：一定要是自己的仓库名，不然所有组件都会加载失败。</strong></p>
<h3 id="hexo的不支持Latex语法">hexo的不支持Latex语法</h3>
<p>我们需要进行重新选择插件进行渲染。</p>
<p>需要重新更新插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件：</p>
<img src="/2023/11/25/create_blog/image-20231127152223788.png" alt="image-20231127152223788" style="zoom:80%;">
<p>修改插件文件，路径<code>\blog\node_modules\kramed\lib\rules\inline.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inline = &#123;</span><br><span class="line">  <span class="comment">// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line">  <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">  <span class="attr">autolink</span>: <span class="regexp">/^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/</span>,</span><br><span class="line">  <span class="attr">url</span>: noop,</span><br><span class="line">  <span class="attr">html</span>: <span class="regexp">/^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;/</span>,</span><br><span class="line">  <span class="attr">link</span>: <span class="regexp">/^!?\[(inside)\]\(href\)/</span>,</span><br><span class="line">  <span class="attr">reflink</span>: <span class="regexp">/^!?\[(inside)\]\s*\[([^\]]*)\]/</span>,</span><br><span class="line">  <span class="attr">nolink</span>: <span class="regexp">/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/</span>,</span><br><span class="line">  <span class="attr">reffn</span>: <span class="regexp">/^!?\[\^(inside)\]/</span>,</span><br><span class="line">  <span class="attr">strong</span>: <span class="regexp">/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/</span>,</span><br><span class="line">  <span class="comment">// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">  <span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">  <span class="attr">code</span>: <span class="regexp">/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/</span>,</span><br><span class="line">  <span class="attr">br</span>: <span class="regexp">/^ &#123;2,&#125;\n(?!\s*$)/</span>,</span><br><span class="line">  <span class="attr">del</span>: noop,</span><br><span class="line">  <span class="attr">text</span>: <span class="regexp">/^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/</span>,</span><br><span class="line">  <span class="attr">math</span>: <span class="regexp">/^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后重新生成运行就可以了。</p>
<h3 id="markdown不支持上标和下标的语法">markdown不支持上标和下标的语法</h3>
<p>使用html来实现上下标，不使用<code>~~和^^</code>。</p>
]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>BLOG</tag>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据理论</title>
    <url>/2023/12/02/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>对数据库中关系的第一范式、第二范式、第三范式等基础理论知识记录说明。</p>
<span id="more"></span>
<h1>基本概念</h1>
<p>函数依赖</p>
<p>一组属性的值可以决定另一组属性的值。$x \rightarrow f(x)$。</p>
<p>非平凡函数依赖：$X\rightarrow Y ;且 Y \nsubseteq X$</p>
<p>平凡函数依赖：$X\rightarrow Y ;且 Y \subseteq X$</p>
<p>完全函数依赖：非主属性完全依赖于主属性，少一个都不能推出。</p>
<p>部分函数依赖：非主属性可以又主属性部分推出得到。</p>
<h1>范式</h1>
<h2 id="第一范式">第一范式</h2>
<p>一个关系模式R的所有属性都是不可分的基本数据项。</p>
<p>反例：</p>
<img src="/2023/12/02/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/image-20231202151257178.png" alt="image-20231202151257178" style="zoom:70%;">
<p>成绩这一列还能再分，不满足第一范式。</p>
<h2 id="第二范式">第二范式</h2>
<p>满足第一范式基础上，<strong>每个非主属性都完全依赖于码。</strong></p>
<table>
<thead>
<tr>
<th>员工编号</th>
<th>销售日期</th>
<th>销售金额</th>
<th>小组编号</th>
<th>组长名称</th>
</tr>
</thead>
</table>
<p>这里员工编号和销售日期可以确定一条销售金额，主属性是员工编号和销售日期，但是由员工编号可以推出小组编号和组长名称。小组编号和组长名称是部分函数依赖于码。所以不满足第二范式。</p>
<p>可拆分表：</p>
<table>
<thead>
<tr>
<th>员工编号</th>
<th>销售日期</th>
<th>销售金额</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>员工编号</th>
<th>小组编号</th>
<th>组长名称</th>
</tr>
</thead>
</table>
<p>从第一范式到第二范式就是<strong>消除非主属性对码的部分函数依赖</strong>。</p>
<h2 id="第三范式">第三范式</h2>
<p>满足第二范式的基础上，每个非主属性对码都不传递依赖于R的候选码。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>员工编号</th>
<th>小组编号</th>
<th>组长名称</th>
</tr>
</thead>
</table>
<p>存在着$员工编号\rightarrow 小组编号$，$员工编号\rightarrow 组长名称$，就有$员工编号\rightarrow 小组编号\rightarrow 组长名称$。存在传递依赖，不满足第三范式。</p>
<p>可拆分表：</p>
<table>
<thead>
<tr>
<th>员工编号</th>
<th>小组编号</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>小组编号</th>
<th>组长名称</th>
</tr>
</thead>
</table>
<p>从第二范式到第三范式就是<strong>消除非主属性对码的传递依赖</strong>。</p>
<h2 id="BC范式">BC范式</h2>
<p>在第三范式基础上，消除主属性对主键的部分和传递依赖。</p>
<p>示例：</p>
<table>
<thead>
<tr>
<th>歌曲编号</th>
<th>歌曲名称</th>
<th>歌手</th>
<th>……</th>
</tr>
</thead>
</table>
<p>这里的歌曲编号、歌曲名称、歌手是候选码（主键），但存在$歌曲名称\rightarrow歌手$的部分依赖，不符合BC范式。</p>
<p>这里第二范式、第三范式都是对非主属性消除部分依赖和传递依赖，BC范式是对主属性消除部分依赖和传递依赖。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
        <tag>关系范式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概述</title>
    <url>/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>简单记录数据库系统的基本理论概念和关系数据库中关系、关系代数等。</p>
<span id="more"></span>
<h1 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h1><ul>
<li>数据：数据库中存储的基本对象。</li>
<li>数据库：是指长期储存在计算机内的、有组织的、可共享的大量数据集合。</li>
<li><strong>数据库管理系统（DBMS）</strong>：建立、管理和维护数据库的软件系统，是一种位于应用软件和操作系统之间，实现数据库管理功能的系统软件。</li>
</ul>
<h2 id="数据模型组成要素"><a href="#数据模型组成要素" class="headerlink" title="数据模型组成要素"></a>数据模型组成要素</h2><ul>
<li><strong>数据结构</strong>：主要描述数据类型、内容、性质的有关情况以及数据间的联系，是对系统静态特征的描述。</li>
<li><strong>数据操作</strong>：主要描述在相应数据结构上的操作类型和操作方式，是对系统动态行为的描述。（CRUD）。</li>
<li><strong>完整性约束条件</strong>：主要描述数据结构内数据间的语法、语义联系，它们之间的制约与依存关系，以及数据动态变化的规则，以此保证数据的正确、有效与相容。</li>
</ul>
<h2 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h2><ul>
<li><p><strong>层次模型</strong></p>
<p>用树形结构表示记录类型和及其联系。</p>
<p>优点：简单、分明、查询效率高、提供良好数据完整性支持。</p>
<p>缺点：不能表示多对多联系，插入和删除限制多、查询子女必须通过双亲结点。</p>
</li>
<li><p><strong>网状模型</strong></p>
<p>网络结构表示实体类型及其实体之间联系的模型。有向图结构表示实体类型及实体间联系的数据模型。</p>
<p>优点：能够更为直接地描述现实客观世界。可表示实体间的多种复杂联系。具有良好的性能，存取效率较高。</p>
<p>缺点：结构比较复杂，数据独立性差。</p>
</li>
<li><p><strong>关系模型</strong></p>
<p>以二维表的形式表示实体数据和实体之间关系的数据模型，它由行和列组成。</p>
<p>优点：具有数学基础、概念单一、存储路径透明。</p>
<p>缺点：查询效率受限。</p>
</li>
<li><p>面向对象模型</p>
<p>基本结构是对象而不是记录，一切事物、概念都可以看做对象。一个对象不仅包括描述它的数据，而且还包括对其进行操作的方法的定义。</p>
</li>
</ul>
<h1 id="数据库内部体系结构"><a href="#数据库内部体系结构" class="headerlink" title="数据库内部体系结构"></a>数据库内部体系结构</h1><p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20231203154911181.png" alt="image-20231203154911181"></p>
<h2 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h2><ul>
<li><p>外模式又称为子模式或用户模式，是模式的子集，是数据的局部逻辑结构，也是数据库用户看到的视图模式。（视图）</p>
</li>
<li><p>模式又称逻辑模式或概念模式，它是数据库中全体数据的全局逻辑结构和特征的描述，也是所有用户的公共视图。</p>
<p>模式实际上是数据库数据在逻辑结构上的视图，一个数据库只有一个模式。</p>
<p>定义模式时不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。（表）</p>
</li>
<li><p>内模式又称存储模式，它是数据在数据库中的内部表示，即数据的物理结构和存储方式的描述，一个数据库只有一个内模式。（物理存储/文件）</p>
</li>
</ul>
<h2 id="二级映像功能"><a href="#二级映像功能" class="headerlink" title="二级映像功能"></a>二级映像功能</h2><ol>
<li><p>外模式/模式映像：每一个外模式都有一个外模式/模式映像，该映像是外模式与模式之间的对应关系。</p>
<p>当模式改变时，有数据管理员对各个外模式/模式映像做相应的改变，以保持外模式不变。</p>
<p>外模式不变，应用程序不必修改，保证数据与程序的逻辑独立性。</p>
</li>
<li><p>模式/内模式映像：定义数据库的全局逻辑结构与存储结构之间的对应关系。该映像是唯一的。</p>
<p>当数据库的存储结构改变时，由管理员对模式/内模式映像做出改变，使得模式保持不变。</p>
<p>模式保持不变、外模式保持不变、应用程序不变，保证数据与程序的物理独立性。</p>
</li>
</ol>
<p><strong>逻辑独立性</strong>是指<strong>应用程序与数据的逻辑结构</strong>之间的独立性，即应用程序的<strong>逻辑结构</strong>不受数据库<strong>内部逻辑结构</strong>的影响。</p>
<p><strong>物理独立性</strong>是指<strong>应用程序与数据的物理结构</strong>之间的独立性，即应用程序的<strong>物理结构</strong>不受数据库<strong>内部物理结构</strong>的影响。</p>
<h1 id="数据库外部体系结构"><a href="#数据库外部体系结构" class="headerlink" title="数据库外部体系结构"></a>数据库外部体系结构</h1><ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户机/服务器结构</li>
<li>浏览器/服务器结构</li>
</ul>
<h1 id="数据库发展阶段"><a href="#数据库发展阶段" class="headerlink" title="数据库发展阶段"></a>数据库发展阶段</h1><h2 id="数据管理初级阶段"><a href="#数据管理初级阶段" class="headerlink" title="数据管理初级阶段"></a>数据管理初级阶段</h2><ul>
<li><p>人工管理阶段</p>
<p>计算机系统不提供对用户数据的管理功能。</p>
<p>数据是面向具体应用的。</p>
<p>不单独保存数据。</p>
</li>
<li><p>文件系统阶段</p>
<p>数据可以长期保存。</p>
<p>数据具有一定的独立性，但独立性差。</p>
<p>数据共享性差，冗余度大——文件是面向应用的。</p>
</li>
</ul>
<h2 id="数据库系统阶段"><a href="#数据库系统阶段" class="headerlink" title="数据库系统阶段"></a>数据库系统阶段</h2><p>特点：<strong>数据结构化；数据冗余度低、实现数据共享；数据独立性高；数据由DBMS统一管理和控制</strong>。</p>
<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><ul>
<li>域是一组具有相同数据类型的值的集合。</li>
<li>笛卡尔积：D1×D2×…×Dn＝{(d1，d2，…，dn)｜di∈Di，i＝1,2,…,n}</li>
<li>分量：笛卡尔积元素（d1，d2，…，dn）中的每一个值di 叫作一个分量。</li>
<li>元组：笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个元组，如果它包含n个值，就叫n元组或简称元组。</li>
<li>笛卡尔积不满足交换律。</li>
</ul>
<p>外码：</p>
<p>设F是基本关系R的一个或一组属性，但不是关系R的码，K是基本关系S的主码。如果F与K相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p>
<h2 id="关系模式三元组"><a href="#关系模式三元组" class="headerlink" title="关系模式三元组"></a>关系模式三元组</h2><p>R(U,D,DOM,F)</p>
<ul>
<li>R是关系名</li>
<li>U为组成该关系的属性名集合</li>
<li>D为属性组U中属性所来自的域</li>
<li>DOM为属性向域的映像集合</li>
<li>F为属性间数据的依赖关系集合</li>
</ul>
<h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p>数据完整性是指数据库中的<strong>数据保持准确、一致和可靠的状态</strong>，<strong>不受非法操作或意外损坏的影响</strong>。</p>
<p>两种数据库完整性的实现方法包括：</p>
<ol>
<li>实体完整性：通过<strong>主键和外键约束</strong>来确保每个表中的数据都是<strong>唯一</strong>的，并且在相关表之间建立正确的关联。</li>
<li>数据完整性：通过<strong>检查约束、默认值和触发器</strong>等手段来确保数据的<strong>准确性和一致性</strong>。</li>
</ol>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li>唯一值约束。</li>
<li>非空值约束。</li>
<li>检查约束。</li>
<li>缺省值约束。</li>
</ul>
<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="并"><a href="#并" class="headerlink" title="并"></a>并</h2><p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20231203202701159.png" alt="image-20231203202701159"></p>
<p>如果R和S都是关系，具有相同的目n，且相应地属性取自同一个域，则R与S的并是由属于R或属于S的元组组成，其结果仍为n目关系，用R∪S表示集合并运算。</p>
<p>记作：R∪S = { t| t Î R∨t Î S }</p>
<h2 id="交"><a href="#交" class="headerlink" title="交"></a>交</h2><p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20231203202735633.png" alt="image-20231203202735633"></p>
<p>如果R和S都是关系，具有相同的目n，且相应地属性取自同一个域，则R与S的交是由既属于R又属于S的元组组成，其结果仍n为目关系，用R∩S表示集合交运算。</p>
<p>记作：R∩S = { t| t Î R∧t Î S }</p>
<h2 id="差"><a href="#差" class="headerlink" title="差"></a>差</h2><p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20231203202802922.png" alt="image-20231203202802922"></p>
<p>如果R和S都是关系，具有相同的目n，且相应地属性取自同一个域，则R与S的差表示由属于R但不属于S的元组组成，其结果仍n为目关系，用R-S表示关系R和S的差。</p>
<p>记作：R -S = { t| t Î R∧t Ï S }</p>
<h2 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h2><p>选择运算又称为限制运算。它是在关系R中选择满足条件的元组，记作： σ<sub>C</sub>(R)= { t | t ∈ R ∧ C(t) =’真’}</p>
<p>C表示选择条件，由逻辑运算符与、或、非连接各算术表达式组成。</p>
<h2 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h2><p>投影是从R中选择出若干属性列组成新的关系。</p>
<p> 记作：$\Pi_A(R)=\{t[A]\;|\;t\in(R)\}$</p>
<p>其中A为R中的属性列。</p>
<h2 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h2><p>等值连接</p>
<p>关系R与S的等值连接是从R和S的广义笛卡尔积R×S中选取A与B等值的那些元组形成的关系。</p>
<p>$R\bowtie S=\{\mathop{tr\;ts}\limits^{\frown}\;|tr\in(R)\wedge ts \in(S)\wedge tr[A]\theta ts[B]\}$</p>
<p>自然连接</p>
<p>$R\bowtie S=\{\mathop{tr\;ts}\limits^{\frown}\;|tr\in(R)\wedge ts \in(S)\wedge tr[A]=ts[A]\}$</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计</title>
    <url>/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>简单记录数据课设计的三个阶段模式，数据字典，ER图。</p>
<span id="more"></span>
<h1 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h1><p>数据库设计步骤</p>
<ul>
<li>需求分析阶段</li>
<li>概念结构设计阶段</li>
<li>逻辑结构设计阶段</li>
<li>物理结构设计阶段</li>
<li>数据库的实施阶段</li>
<li>数据库运行和维护阶段</li>
</ul>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>通过详细调查现实世界要处理的对象(组织、部门、企业等)，充分了解原系统(手工系统或计算机系统)工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。</p>
<ul>
<li>调查重点：<strong>数据</strong>和<strong>业务处理</strong>。</li>
<li>确定业务规则。</li>
<li>业务规则：业务处理数据以及产生数据的方法和步骤。</li>
</ul>
<p>业务及数据分析</p>
<ol>
<li>确定业务</li>
<li>业务流程分析</li>
<li>业务规则分析</li>
<li>数据流程分析</li>
</ol>
<h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><ul>
<li><p><strong>数据项</strong>是不可再分的数据单元。</p>
<p>数据项描述：数据项编号、数据项名，数据项含义说明、别名、数据类型、长度、取值访问、取值含义、与其他数据项的逻辑关系。</p>
</li>
<li><p><strong>数据结构</strong>反映数据之间的组合关系，由若干个数据项组成，或者是若干个数据结构组成。</p>
<p>数据结构描述：数据结构编号、数据结构名称、含义说明，组成。</p>
</li>
<li><p><strong>数据流</strong>是数据结构在系统内传输途径，表示某一个过程的输入或输出。</p>
<p>数据流描述：数据流名、说明、数据流来源、数据流去向、组成、平均流量、高峰期流量。</p>
</li>
<li><p><strong>数据存储</strong>是数据结构停留或保存的地方，也是数据流的来源和去向。</p>
<p>数据存储描述：数据存储编号、说明、编号、流入的数据流、流出的数据流、组成、数据量、存取方式。</p>
</li>
<li><p><strong>处理过程</strong>描述业务处理的处理逻辑和输入、输出。</p>
<p>处理过程描述：处理过程编号，处理过程名，说明，输入数据流，输出数据流，处理简要说明。</p>
</li>
</ul>
<h1 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h1><p>概念模型是现实世界和机器世界的中介，既独立于数据库的逻辑结构，也独立于某一数据库管理系统，概念模型必须能够真实充分的反映现实世界。</p>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>实体之间的联系：</p>
<ol>
<li>1对1</li>
<li>1对多</li>
<li>多对多</li>
</ol>
<p>实体用矩形表示。</p>
<p>属性用椭圆形表示。</p>
<p>联系用菱形表示。</p>
<p>示例：</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203141224150.png" alt="image-20231203141224150"></p>
<h2 id="概念结构设计方法步骤"><a href="#概念结构设计方法步骤" class="headerlink" title="概念结构设计方法步骤"></a>概念结构设计方法步骤</h2><ul>
<li><p>自顶向下方法</p>
<p>从全局出发，先设计出全局概念模型框架，然后逐步细化。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203141724418.png" alt="image-20231203141724418"></p>
</li>
<li><p>自底向上方法</p>
<p>从局部应用出发，先设计出各局部应用的概念模型，然后再对局部应用的概念模型进行综合，形成全局概念模型。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203141731681.png" alt="image-20231203141731681"></p>
</li>
<li><p>逐步扩张方法</p>
<p>首先定义最基本、最核心的概念模型，逐步扩大至其相关的概念模型，以滚雪球的方式进行概念模型的扩张，最终形成全局的概念模型。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203141738620.png" alt="image-20231203141738620"></p>
</li>
<li><p>混合策略方法</p>
<p>采用自顶向下和自底向上相结合的方法。用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成自底向上策略中设计的各局部概念接结构。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203141747092.png" alt="image-20231203141747092"></p>
</li>
</ul>
<h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><p><strong>抽象方法-分类</strong></p>
<p>分类定义某一概念作为现实世界中一组对象的类型，这些对象具有某些共同的特性和行为。</p>
<p>它抽象了对象值和型之间的“is member of”的语义。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203142030070.png" alt="image-20231203142030070"></p>
<p><strong>抽象方法-聚集</strong></p>
<p>聚集是将若干对象和它们之间的联系组合成一个新的对象。</p>
<p>它抽象了对象内部类型和成分之间“is part of”的语义。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203142117077.png" alt="image-20231203142117077"></p>
<p><strong>抽象方法-概括</strong></p>
<p>概括将一组具有共同特性的对象合并成更高一层意义上的对象。</p>
<p>它抽象了类型之间的“is subset of”的语义。</p>
<p><img src="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231203142154509.png" alt="image-20231203142154509"></p>
<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系模式示例：</p>
<p>商品（<u>商品编码</u>，商品名，条形码，进价，售价，单位，备注，数量，仓库号）</p>
<p>仓库（<u>仓库号</u>，仓库电话，仓库面积）</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
        <tag>数据字典</tag>
        <tag>关系模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库的管理和维护</title>
    <url>/2023/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<p>简单记录数据库的安全管理、并发控制中的事务，备份和恢复管理。</p>
<span id="more"></span>
<h1 id="安全性管理"><a href="#安全性管理" class="headerlink" title="安全性管理"></a>安全性管理</h1><h2 id="SQL-server三级认证作用以及认证和授权内容"><a href="#SQL-server三级认证作用以及认证和授权内容" class="headerlink" title="SQL server三级认证作用以及认证和授权内容"></a>SQL server三级认证作用以及认证和授权内容</h2><ul>
<li>服务器级别认证：身份验证，通过操作系统级别的安全验证来访问数据库系统。</li>
<li>数据库级别认证：通过数据库用户账户进行控制，要访问一个数据库，必须拥有一个数据库的一个用户账号身份，该用户对应的权限访问数据库中的数据。</li>
<li>数据库对象级别认证：常见的数据库对象级别认证包括对表、视图、存储过程、函数等数据库对象的访问权限控制。</li>
</ul>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><ul>
<li>对象权限：用户是否具有权限执行某一语句，主要用于控制创建数据库或数据库中对象而涉及的权限。（CRUD）。</li>
<li>语句权限：用户对数据库执行操作的权限。(创建数据库、视图、表、存储函数等)。</li>
<li>隐私权限：系统预定义而不需要授权就有的权限，包括固定服务器角色、固定数据库角色和数据库对象所有者所拥有的权限。</li>
</ul>
<p>权限操作</p>
<p>授权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant [权限名] on [数据库名.表名] to [用户名@IP地址]</span><br></pre></td></tr></table></figure>
<p>撤销权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke [权限名] on [数据库名.表名] to [用户名@IP地址]</span><br></pre></td></tr></table></figure>
<p>禁止权限</p>
<p>MySQL中没有禁止权限，通过撤销权限来实现禁止。</p>
<p>SQL server：<code>deny [权限名] on [数据库名.表名] to [用户名@IP地址]</code>。</p>
<p>权限查看</p>
<p>MySQL：<code>show grants</code>，<code>show grants for &#39;username&#39;@&#39;localhost&#39;</code>。</p>
<p>SQL server：<code>execute sp_helprotect [@name=&#39;对象名或授权语句名&#39;, @username=&#39;用户名&#39;, @grantorname=&#39;授权的用户账号名&#39;]</code>。</p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是由用户定义的一系列数据操作语句构成，这些操作语句要么全部执行要么全部不执行，是数据库运行的最小的、不可分割的工作单位。</p>
<p><strong>ACID</strong></p>
<ul>
<li>原子性：一个事务对于数据的所有操作都是不可分割的整体，要么全部执行，要么全部不执行。</li>
<li>一致性：事务执行完成后，数据库中的内容必须全部更新，确保数据一致性。</li>
<li>隔离性：一个事务执行不能被其他事务干扰，一个事务内部操作及其使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持续性：一个事务一旦提交，它对数据库中数据的改变就是永久的。</li>
</ul>
<p>显示事务：事务有显示的开始和结束标记。</p>
<p>MySQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line">begin;</span><br><span class="line"># 回滚事务</span><br><span class="line">rollback;</span><br><span class="line"># 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>SQL server：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> transact;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>隐式事务：每一条数据操作语句都自动成为一个事务。</p>
<h2 id="并发控制概述"><a href="#并发控制概述" class="headerlink" title="并发控制概述"></a>并发控制概述</h2><p>并发执行能提高系统资源的利用率，改善短事务的响应时间，但并发执行可能破坏事务的ACID特性。</p>
<h3 id="并发操作导致的问题"><a href="#并发操作导致的问题" class="headerlink" title="并发操作导致的问题"></a>并发操作导致的问题</h3><ul>
<li><strong>丢失更新</strong>：两个或两个以上的事务在更新同一数据值时，会发生某些修改被覆盖（丢失）的问题。（都在更新，但后面的更新数值覆盖前面更新结果，最后数值不对）。</li>
<li><strong>读“脏”数据</strong>：一个事务读取了另一个事务失败运行过程中的数据。事务T1更新数值，事务T2读取了这个数值，但事务T1失败了，回滚事务，事务T2读的数值和数据库中不一致。<strong>一个事务读到另一个事务还没有提交的数据</strong>。</li>
<li><strong>不可重复读</strong>：不可重复读是指事务T1读取数据后，事务T2对该数据进行读取并执行更新操作，修改了T1读取的数据，T1操作完数据后，又重新读取这个数据，会发现读到的结果与前一次不一样。<strong>一个事务先后读取同一条记录，但两次读取的数据不同</strong>。</li>
<li><strong>幻读</strong>：<strong>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</strong>。</li>
</ul>
<h3 id="并发控制方法"><a href="#并发控制方法" class="headerlink" title="并发控制方法"></a>并发控制方法</h3><p><strong>排他锁</strong></p>
<p>写锁，只允许一个事务对数据进行修改，其他事务无法同时对该行数据进行读取或修改操作。</p>
<p><strong>共享锁</strong></p>
<p>读锁，允许多个事务同时读取同一行数据，但不允许任何事务对该行数据进行修改。</p>
<h2 id="封锁技术"><a href="#封锁技术" class="headerlink" title="封锁技术"></a>封锁技术</h2><ul>
<li>一级封锁协议：事务在修改数据对象之前必须对其加X锁，直到事务结束时才释放锁。可以防止丢失更新的问题，当不能保证可重复读和脏读。</li>
<li>二级封锁协议：是指在一级封锁协议基础上，加上事务T在读取数据之前必须先对其加S锁，<strong>读取完后立即释放S锁</strong>。可以防止数据丢失更新、读“脏”数据。</li>
<li>三级封锁协议：指在一级封锁协议基础上，加上事务T在读取数据之前必须先对其加S锁，<strong>读取完后并不释放S锁，直到事务T结束才释放</strong>。可以防止丢失更新、不读“脏”数据，不可重复读。</li>
</ul>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>某一个事务一直等待锁，进程“饿死”状态。</p>
<p>通过先来先服务解决。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>每个事务相互等待其他事务释放封锁，都不能进行。</p>
<p>死锁预防：</p>
<ul>
<li>一次性封锁：要求每个事务必须一次性将所有要使用的诗句全部加锁后执行。扩大了封锁的范围，降低了系统的并发度。</li>
<li>顺序封锁：要求所有事务必须按照一个预先约定的封锁顺序对所要用到的数据对象进行封锁。很难预先确定所有数据对象的加锁顺序。</li>
</ul>
<p>死锁诊断和解除：</p>
<ul>
<li>超时法：对每个锁设定一个时限，如果某个事务的等待时间超过了该时限，就认为发生了死锁，此时调用解锁程序，以解除死锁。时限难于设置，若设置太长，则会导致死锁发生后不能及时发现；也有可能误判死锁。</li>
<li>事务等待图法：特殊的有向图G=(T,U)。T为结点的集合，每个结点表示正在运行的事务；U 为边的集合，每条边表示事务等待的情况。若T1等待T2，那么T1、T2之间划一条有向边，从T1指向T2。建立事务等待图之后，诊断死锁的问题就变成了判断有向图G中是否存在回路的问题。</li>
</ul>
<h3 id="并发调度可串行性"><a href="#并发调度可串行性" class="headerlink" title="并发调度可串行性"></a>并发调度可串行性</h3><p>多个并发执行是正确的，当且仅当结果与按某一顺序串行的执行这些事务时的结果相同，则称这种调度策略为可串行化的调度。</p>
<p>可串行性是并发事务正确调度的准则。目前数据库管理系统普遍采用<strong>两段锁协议</strong>来实现并发调度的可串行化，从而保证调度的正确性。</p>
<p>事务必须分为两个阶段对数据对象进行加锁和解锁：</p>
<ul>
<li><p>在对任何数据进行读写操作之前，要先申请并获得对该数据的封锁。</p>
<p>事务可以申请获得任何数据对象上的任何类型的锁，但是不允许释放任何锁。</p>
</li>
<li><p>在释放一个封锁之后，事务不再申请和获得对该数据的封锁。</p>
<p>事务可以释放任何数据对象上的任何类型的锁，但不允许申请任何锁。</p>
</li>
</ul>
<p>事务遵守两段封锁协议是可串行化调度的<strong>充分条件，而不是必要条件</strong>。</p>
<h1 id="备份及恢复管理"><a href="#备份及恢复管理" class="headerlink" title="备份及恢复管理"></a>备份及恢复管理</h1><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><ul>
<li><p><strong>完全备份</strong></p>
<p>将备份整个数据库，不仅包括用户表、系统表、索引、视图、存储过程等所有数据库对象，还包括事务日志部分。</p>
<p>MySQL在cmd命令行实现完全备份和恢复：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完全备份</span></span><br><span class="line">mysqldump -u username -p mydatabase &gt; backup.sql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还原备份</span></span><br><span class="line">mysql -u username -p mydatabase &lt; backup.sql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>差分备份</strong></p>
<p>仅备份自上次完全备份以来数据改变部分的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份名为mydatabase的数据库中表mytable中<span class="built_in">id</span>大于100的行</span></span><br><span class="line">mysqldump -u username -p mydatabase mytable --where=&quot;id &gt; 100&quot; &gt; diff_backup.sql</span><br></pre></td></tr></table></figure>
<p>恢复和完全备份相同。</p>
</li>
</ul>
<ul>
<li><p><strong>事务日志备份</strong></p>
<p>对事务日志进行备份，备份时复制自上次备份以来对数据库所做的改变。</p>
<p>事务日志备份和差分备份有所不同。差分备份无法将数据库恢复到出现故障前某一个指定的时刻，它只能将数据库恢复到上一次差分备份结束的时刻。</p>
</li>
<li><p><strong>文件或文件组备份</strong></p>
<p>数据库由磁盘上的许多文件构成。如果数据库非常大，执行完全备份是不可行的，可以使用文件备份或文件组备份来备份数据库的一部分。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
        <tag>并发控制</tag>
        <tag>事务管理</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              主要说明网络层IP层的基本概念和相关协议，以及协议的工作流程等基本理论知识。</p>
<span id="more"></span>
<h1>基本概念</h1>
<ul>
<li>网络的工作主要就是对IP协议的基本内容。</li>
<li>网络层不提供服务质量保证，有运输层来保证。</li>
</ul>
<p>网络连接设备：</p>
<ol>
<li>物理层：转发器</li>
<li>数据链路层：网桥、交换机</li>
<li>网络层：路由器</li>
<li>网关：网络层</li>
</ol>
<h1>网际协议IP</h1>
<p>网际协议IP配套使用三种协议：</p>
<ul>
<li>地址解析协议（ARP）</li>
<li>网际控制报文协议（ICMP）</li>
<li>网际组管理协议（IGMP）</li>
</ul>
<h2 id="IP地址">IP地址</h2>
<p><strong>全球范围唯一的32位标识符</strong></p>
<p><img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129164207215.png" alt="image-20231129164207215"></p>
<h3 id="分类的IP地址">分类的IP地址</h3>
<p>分为A、B、C、D、E类地址。</p>
<ul>
<li>A（8位）、B（16位）、C（24位）类是单播地址，最常用</li>
<li>D类是多播地址（一对多通信）</li>
<li>E类是保留地址</li>
</ul>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129164502642.png" alt="image-20231129164502642" style="zoom:80%;">
<h4 id="不指派的IP">不指派的IP</h4>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129165910304.png" alt="image-20231129165910304" style="zoom:80%;">
<p>主要是注意全0表示位网络的网络号，全1表示该网络的广播地址。</p>
<h3 id="无分类编址CIDR">无分类编址CIDR</h3>
<p><code>/</code>后的数字来指定网络前缀，以此确定网络号</p>
<p><img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129165624467.png" alt="image-20231129165624467"></p>
<p>斜线后面的数字就是地址掩码中1的个数。</p>
<ul>
<li>前缀n =32，即32位IP 地址都是前缀，没有主机号。这其实就是一个IP 地址。这个特殊地址用于主机路由。</li>
</ul>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129170621284.png" alt="image-20231129170621284" style="zoom:80%;">
<p>同一局域网中主机的网络前缀相同。</p>
<h4 id="划分子网">划分子网</h4>
<h2 id="IP地址与MAC地址">IP地址与MAC地址</h2>
<p>MAC地址成为硬件地址或物理地址。</p>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129170944235.png" alt="image-20231129170944235" style="zoom:80%;">
<ul>
<li>IP 地址放在 IP 数据报的首部。</li>
<li>MAC 地址则放在 MAC 的首部。</li>
<li>在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是 MAC 地址。</li>
<li>当IP数据报插入到数据链路层的 MAC 以后，整个的IP数据报就成为 MAC的数据，因而在数据链路层看不见数据报的IP地址。</li>
</ul>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129171408560.png" alt="image-20231129171408560" style="zoom:80%;">
<ol>
<li>
<p>在IP层抽象的互联网上只能看到IP数据报，在数据包传送过程中<strong>IP的源地址和目的地址始终不变</strong>。</p>
</li>
<li>
<p>路由器只根据目的站的IP地址进行转发。</p>
</li>
<li>
<p>在不同网络上传送时，其MAC首部中的源地址和目的地址要发生变化。</p>
<p>如图所示，开始在H到间传送时，MAC首部中写的是从MAC地址MAC<sub>1</sub>发送到MAC<sub>3</sub>地址。路由器R<sub>1</sub>收到此MAC后，在数据链路层，要剥去原来的MAC的首部和尾部。在转发时，在数据链路层，要重新添加上MAC的首部和尾部。这时首部中的源地址和目的地址分别变成为MAC<sub>4</sub>和MAC<sub>5</sub>。</p>
</li>
</ol>
<h1>地址解析协议ARP</h1>
<p>地址解析协议ARP主要是为了解决主机<strong>通过IP地址找到相应的MAC地址</strong>。</p>
<p>在主机的<strong>ARP高速缓冲</strong>存放从IP地址到MAC地址的映射表，映射表动态更新。</p>
<h2 id="工作流程">工作流程</h2>
<p>主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的MAC地址，再把这个MAC地址写入MAC，然后通过局域网把该MAC发往此MAC地址。</p>
<p>如果没有则执行以下步骤：</p>
<ol>
<li>ARP进程在本局域网上<strong>广播</strong>发送一个ARP请求分组</li>
<li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</li>
<li>主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址</li>
<li>其余所有主机的IP地址都与ARP请求分组中要查询的P地址不一致，因此都不理睬这个ARP请求分组。</li>
<li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射。</li>
</ol>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129211609859.png" alt="image-20231129211609859" style="zoom:80%;">
<ul>
<li>发送方是主机(如H<sub>1</sub>)，要把IP数据报发送到同一个网络上的另一台主机(如H<sub>2</sub>)。这时H<sub>1</sub>发送ARP请求分组(在网络N<sub>1</sub>上广播)，找到目的主机H<sub>2</sub>的MAC地址。</li>
<li>发送方是主机(如H<sub>1</sub>)，要把IP数据报发送到另一个网络上的一台主机(如 H<sub>3</sub>或H<sub>4</sub>)。这时H<sub>1</sub>发送ARP请求分组(在网络N<sub>1</sub>上广播)，找到上的一个路由器R<sub>1</sub>的MAC地址。</li>
<li>发送方是路由器(如R<sub>1</sub>，要把IP数据报转发到与连接在同一个网络N<sub>2</sub>上的主机(如H<sub>3</sub>)。这时R发送ARP请求分组(在N<sub>2</sub>上广播)，找到目的主机H<sub>3</sub>的MAC地址。</li>
<li>发送方是路由器(如R<sub>1</sub>)，要把IP数据报转发到网络N<sub>3</sub>的一台主机(如H<sub>4</sub>），H<sub>4</sub>与R<sub>1</sub>不是连接在同一个网络上的。这时R<sub>1</sub>发送ARP请求分组(在N<sub>2</sub>上广播)，找到连接在N<sub>3</sub>上的一个路由器R<sub>2</sub>的MAC地址。</li>
</ul>
<h1>IP数据报格式</h1>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129212448388.png" alt="image-20231129212448388" style="zoom:80%;">
<p>首部宽度32位（4字节），IP数据报由首部和数据部分两部分组成。</p>
<ul>
<li>
<p><strong>首部长度：占4位，能够表示最大十进制为15，表示单位是32位字长（4字节），也就是说首部最长为$15\times4=60$个字节</strong>。</p>
<p>IP首部固定是20个字节，也就是前四排，第五排是可选字段，通过首部长度可以算出可选字段的长度。</p>
<p>首部长度长度单位是32位字长（4字节），所以首部长度一定是4字节整数倍，不足用填充字段补充。</p>
</li>
<li>
<p>总长度：指整个IP数据报的长度，通过和首部长度计算出数据部分的长度。</p>
<p>IP数据报长，能够提高传输效率。数据报短，路由转发速度快，各有好处。</p>
<p><strong>但以太网规定最大的传输单元MTU是1500字节，如果IP数据报过长，需要对数据报进行分片处理</strong>。</p>
</li>
<li>
<p>标志：占3位，只有两位有意义。</p>
<p><strong>最低为MF，MF=1 表示后面“还有分片”的数据报；MF=0 表示这已是若干数据报片的最后一个。</strong></p>
<p><strong>中间是DF，DF=0 允许分片。</strong></p>
</li>
<li>
<p>片偏移：占13位，指在<strong>原分组中的相对位置，该片从何处开始</strong>。<strong>片偏移以8个字节为偏移单位</strong>。除最后一个数据报片外，其他每个分片的长度一定是 8 字节(64 位)的整数倍。</p>
</li>
<li>
<p>生存时间位：（8位，TTL(Time To Live)）每经过一个路由器时，就把TTL减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒，就把TTL值减1。当TTL值减为零时，就丢弃这个数据报。</p>
</li>
<li>
<p><strong>首部检验和：占16位，只检验数据报的首部，但不包括数据部分</strong>。</p>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129214842428.png" alt="image-20231129214842428" style="zoom:80%;">
</li>
</ul>
<h1>IP分组转发</h1>
<ul>
<li>从收到的分组的首部提取目的主机的IP地址D(即目的地址)。</li>
<li>若查找到有特定主机路由(目的地址为D)，就按照这条路由的下一跳转发分组，否则从转发表中下一行(也就是前缀最长的一行)开始检查。</li>
<li>把这一行的<strong>子网掩码与目的地址D按位进行AND运算，若运算结果与本行的前缀匹配</strong>，则查找结束，按照“下一跳”所指出的进行处理(或直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器)。</li>
<li>若为没有对应的网络，则使用默认路由，则按照指明的接口，把分组传送到指明的默认路由器，否则，报告转发分组出错。</li>
</ul>
<p>核心就是将目的地址和子网掩码进行AND运算，判断是否是对应的网路前缀，如果是则发送到指定的下一跳。</p>
<p>在和掩码进行AND运算时，可能有多个转发结果，此时需要采用<strong>最长前缀匹配的原则</strong>进行跳转。</p>
<h1>网际控制报文协议ICMP</h1>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231130090900230.png" alt="image-20231130090900230" style="zoom:80%;">
<p>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
<p>ICMP是IP层的协议，作为数据部分封装到IP数据报的数据部分中。</p>
<h2 id="ICMP差错报告报文">ICMP差错报告报文</h2>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231130091723540.png" alt="image-20231130091723540" style="zoom:80%;">
<p>把收到的需要进行差错报告的 <strong>IP 数据报的首部和数据字段的前8个字节</strong>提取出来，作为 ICMP 报文的数据字段。再加上相应的<strong>ICMP 差错报告报文的前8个字节</strong>，就构成了ICMP 差错报告报文。</p>
<p>提取收到的数据报的数据字段前 8 个字节是为了得到<strong>运输层的端口号</strong>(对于 TCP和UDP)以及<strong>运输层报文的发送序号</strong>。</p>
<p>ICMP差错报告报文共有4种：</p>
<ul>
<li><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li>
<li><strong>时间超过</strong>：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>
<li><strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时就丢弃该数据报，并向源点发送参数问题报文。</li>
<li><strong>改变路由（重定向）</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（找到更好的路由转发）。</li>
</ul>
<p>不发送ICMP报文的几种情况：</p>
<ul>
<li>对ICMP差错报告报文，不再发送ICMP差错报告报文。</li>
<li>对第一个分片的数据报片的所有后续数据报片，都不发送ICMP 差错报告报文。</li>
<li>对具有多播地址的数据报，都不发送ICMP 差错报告报文。</li>
<li>对具有特殊地址(如127.0.0.0 或0.0.0.0)的数据报，不发送ICMP 差错报告报文。</li>
</ul>
<h2 id="ICMP询问报文">ICMP询问报文</h2>
<p>分为两类：</p>
<ul>
<li><strong>回送请求或回送回答</strong>：主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这<br>
种询问报文用来测试目的站是否可达以及了解其有关状态。</li>
<li><strong>时间戳请求或时间戳回答</strong>：在 ICMP 时间戳请求报文发出后，就能够收到对方响应的 ICMP 时间戳回答报文。利用在报文中记录的时间戳(如报文的发送时间和接收时间)，发送方计算出当前网络的往返时延。</li>
</ul>
<h1>路由选择协议</h1>
<h2 id="内部网关协议">内部网关协议</h2>
<h3 id="RIP协议">RIP协议</h3>
<p>基于距离向量的路由选择协议，路由器都要维护从它自己到其他<strong>每一个目的网络的距离记录</strong>。路由器到直接连接的网络的距离定义为 1，从主机到非直接连接的网络的距离定义为所经过的路由器数加1。RIP 允许一条路径<strong>最多只能包含 15个网络</strong>。因此“距离”等于16时即相当于不可达，只<strong>适用于小型互联网</strong>。RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条<strong>具有最少网络数的路由</strong>(即最短路由)。</p>
<h4 id="特点">特点</h4>
<ul>
<li>仅和相邻路由器交换信息，不相邻的路由器不交换信息。</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息，到本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器。</li>
<li>按固定的时间间隔交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。主机虽然也运行协议 RIP，但只被动地接收路由器发来的路由信息。</li>
</ul>
<p>RIP协议就是路由器和<strong>自己相邻的路由器交换路由表信息</strong>，更新保存到本自治网络中所有目的网络的<strong>最短距离</strong>的路由转发<strong>下一跳的位置</strong>。</p>
<h4 id="距离向量算法">距离向量算法</h4>
<p>对每一个相邻路由器发送过来的 RIP 报文，执行以下步骤：</p>
<ol>
<li>对地址为X的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。项目有三个关键数据，即：到目的网络 Net，距离是d，下一跳路由器是X。</li>
<li>对修改后的RIP 报文中的每一个项目，进行以下步骤：
<ol>
<li>若原来的路由表中没有目的网络 Net，则把该项目添加到路由表中。</li>
<li>若原来的路由表有目的网络 Net，则检测下一条是否是 X，如果是则更新为最新的记录，如果不是，则判断距离，更新为距离小的记录，距离相等则不更新。</li>
</ol>
</li>
<li>若三分钟没有收到相邻路由器的更新路由表，则将此相邻路由器即为不可达的路由器，距离设置为16。</li>
</ol>
<p>协议RIP一特点：<strong>好消息传播快、坏消息传播慢</strong>。</p>
<h3 id="OSPF协议">OSPF协议</h3>
<p>开放最短路径优先，使用了最短路径算法 SPF，主要特征是使用链路状态协议。</p>
<h4 id="特点-2">特点</h4>
<ul>
<li>路由器通过所有输出端口向所有相邻路由器发送信息，每个相邻的路由器又将此信息发送到所有的相邻路由器（不在发送刚刚发来消息的那个路由器），采用的泛洪法。</li>
<li>发送消息是本路由器相邻的所有路由器的链路状态，（链路状态是说明本路由器和那些路由器相邻，以及该链路的“度量”）。</li>
<li>当链路状态发生变化或每隔一段时间（30分钟），路由器向所有路由器使用泛洪法发送链路状态信息。</li>
</ul>
<p>各路由器都能建立一个链路状态数据库（全网的拓扑结构图），OSPF协议更新收敛快</p>
<h2 id="外部网关协议">外部网关协议</h2>
<p>BG 是不同自治系统的路由器之间交换路由信息的协议。</p>
<ul>
<li>
<p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” 。</p>
</li>
<li>
<p>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。</p>
</li>
</ul>
<p>BGP发言者之间交换信息。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-运输层</title>
    <url>/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>总结计算机网络运输层知识，主要是TCP和UDP协议特点。</p>
<span id="more"></span>
<h1>运输层协议概述</h1>
<ol>
<li>运输层向上面的应用层提供通信服务。</li>
<li>两台主机进行通信是主机中的应用进程相互通信。</li>
<li>网络层为主机之间的通信提供服务，而运输层在网络层基础上，为应用进程之间的通信提供服务。</li>
<li>TCP协议提供可靠协议，通过差错检测等方式在逻辑上实现，而底层网络层通信时不可靠的。</li>
<li>TCP是逻辑上的一条全双工的可靠通信，UDP协议是不可靠通道。</li>
<li>运输层两个主要协议用户数据报协议UDP和传输控制协议TCP。<strong>UDP传输数据前不需要建立连接，而TCP是提供面向连接的服务</strong>。</li>
</ol>
<table>
<thead>
<tr>
<th>运输层协议</th>
<th>应用层协议</th>
<th style="text-align:center">协议全称</th>
<th>默认端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>HTTP</td>
<td style="text-align:center">HyperText Transfer Protocol（超文本传输协议）</td>
<td>80</td>
</tr>
<tr>
<td>TCP</td>
<td>FTP</td>
<td style="text-align:center">File Transfer Protocol (文件传输协议)</td>
<td>20用于传输数据<br>21用于传输控制信息</td>
</tr>
<tr>
<td>TCP</td>
<td>SMTP</td>
<td style="text-align:center">Simple Mail Transfer Protocol (简单邮件传输协议)</td>
<td>25</td>
</tr>
<tr>
<td>TCP</td>
<td>TELNET</td>
<td style="text-align:center">Teletype over the Network (网络电传)</td>
<td>23</td>
</tr>
<tr>
<td>TCP</td>
<td>SSH</td>
<td style="text-align:center">Secure Shell</td>
<td>22</td>
</tr>
<tr>
<td>UDP</td>
<td>DNS</td>
<td style="text-align:center">Domain Name Service (域名服务)</td>
<td>53</td>
</tr>
<tr>
<td>UDP</td>
<td>TFTP</td>
<td style="text-align:center">Trivial File Transfer Protocol (简单文件传输协议)</td>
<td>69</td>
</tr>
<tr>
<td>UDP</td>
<td>SNMP</td>
<td style="text-align:center">Simple Network Management Protocol (简单网络管理协议)</td>
<td>通过UDP端口161接收<br>只有Trap信息采用UDP端口162</td>
</tr>
<tr>
<td>UDP</td>
<td>NTP</td>
<td style="text-align:center">Network Time Protocol (网络时间协议)</td>
<td>123</td>
</tr>
</tbody>
</table>
<h1>用户数据报协议UDP</h1>
<h2 id="特点">特点</h2>
<ol>
<li>无连接，发送数据前不需要建立连接。</li>
<li>使用尽最大努力交付，不保证可靠交付。</li>
<li>面向报文。UDP一次传送和交付一个完整的报文。</li>
<li>没有拥塞控制。网络出现拥塞不会是源主机的发送速率降低。</li>
<li>支持一对一、一对多、多对一、多对多等交互通信。</li>
<li>首部开销小，只有8个字节。</li>
</ol>
<p>复用：将UDP用户数据报组装成不同的IP数据报，发送到互联网。</p>
<p>分用：根据UDP用户数据报首部中的目的端口号，将数据报分别传送到相应端口，以便应用进到端口读取数据。</p>
<p>分用时，找不到对应的目的端口号，丢弃报文，并给发送方发送ICMP“端口不可达”错误报告报文。</p>
<h2 id="UDP首部格式">UDP首部格式</h2>
<p>UDP数据报两个字段，数据字段和首部字段，首部字段只有8个字节，由4个字段组成，每个字段的长度都是2个字节。</p>
<ul>
<li>源端口：源端口号。</li>
<li>目的端口：目的端口号。</li>
<li>长度：UDP数据报的长度，最小为8（首部）。</li>
<li>检验和：检测UDP用户数据报在传输过程中是否有错，有错就丢弃。</li>
</ul>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231130145409968.png" alt="image-20231130145409968" style="zoom:50%;">
<p>校验和生成：</p>
<ol>
<li>填上伪首部。</li>
<li>全零填充校验和字段。</li>
<li>如果UDP数据报加上伪首部总长度不是2字节的倍数，则全0填充数据部分，补充为2字节的倍数。</li>
<li>伪首部+首部+数据部分采用二进制反码求和。</li>
<li>将和进行求反码填入校验和字段。</li>
</ol>
<p>检验和检验：</p>
<ol>
<li>填上伪首部。</li>
<li>伪首部+首部+数据部分采用二进制反码求和。</li>
<li>结果全为1则无差错，否则对其数据报/交给应用层附上差错警告。</li>
</ol>
<h1>传输控制协议TCP</h1>
<h2 id="特点-2">特点</h2>
<ol>
<li>TCP是<strong>面向连接的运输层协议</strong>，在使用TCP协议之前，必须要建立TCP连接，传输完毕后，释放连接。</li>
<li>TCP是端到端通信（点对点）。</li>
<li>TCP提供<strong>可靠交付</strong>的服务，无差错、不丢失、不重复，并且按序到达。</li>
<li>TCP提供<strong>全双工通信</strong>，TCP连接的两端都设有发送缓存和接收缓存。</li>
<li>TCP是<strong>面向字节流</strong>。把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<h2 id="TCP首部格式">TCP首部格式</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201105345130.png" alt="image-20231201105345130" style="zoom:50%;">
<ul>
<li>
<p>源端口和目的端口：各占两个字节。</p>
</li>
<li>
<p>序号：4个字节，TCP是面向字节流的，序号记录的数据部分第一个字节在原数据的字节序号。</p>
</li>
<li>
<p>确认号：期望收到对方下一个报文段的第一个数据字节的序号。<br>
$$<br>
若确认号=N,则表明:到序号N-1为止的所有数据都已正确收到。<br>
$$</p>
</li>
<li>
<p>数据偏移：指出TCP的首部长度，单位是32位（4字节），数据偏移的最大值是60字节（TCP首部的最大长度），占4位。</p>
</li>
<li>
<p>紧急URG：URG=1，表示紧急指针字段有效，该报文段有紧急数据，具有高优先级，不必再原来排队顺序等待传送。</p>
</li>
<li>
<p>确认ACK：ACK=1时确认号字段才有效，TCP建立建立后所有报文段都必须把ACK置为1。</p>
</li>
<li>
<p>复位RST：TCP连接中出现严重差错，必须释放连接，重新建立运输连接。</p>
</li>
<li>
<p>同步SYN：连接建立用来同步序号，SYN=1而ACK=0，表明这是一个连接请求报文段。</p>
</li>
<li>
<p>终止FIN：释放连接。</p>
</li>
<li>
<p>窗口：窗口值作为接收方让发送方设置其发送窗口的依据。</p>
</li>
<li>
<p>校验和：加上伪首部进行计算校验和，检验范围包括首部和数据两部分，占两个字节。</p>
</li>
</ul>
<h1>停止等待协议</h1>
<ul>
<li>
<p>发送完一个分组就停止发送、等待对方的确认，收到确认后再发送下一个分组。</p>
</li>
<li>
<p>设置超时重传机制。当发送方在超过一定时间未收到接受方发来的确认，则再发送一次该分组。</p>
<p>发送方发送完一个分组后必须要保留已发送分组的副本，超时重传需要再次发送，只有收到相应的确认后才能清除分组副本。</p>
<p>超时重传设置时间比分组传输的平局往返时间更长些，超时重传的时间通过动态计算来更新：<br>
$$<br>
新的RTT_S=(1-\alpha)\times(旧的RTT_S)+\alpha\times(新的RTT样本)<br>
$$</p>
<blockquote>
<p>计算会给出多个RTT样本，每一个都要带入公式计算，而不是样本取平均再带入计算。</p>
<p>如果报文段重传了，就不采用其往返时间样本，不参与计算。</p>
</blockquote>
</li>
</ul>
<p>确认和重传禁止，可以在不可靠的传输网络上实现可靠通信，该协议常称为自动重传请求ARQ。</p>
<p>信道利用率计算：<br>
$$<br>
U=\frac{T_D}{T_D+RTT+T_A}<br>
$$</p>
<ul>
<li>T<sub>D</sub>：发送方发送分组消耗时间。</li>
<li>RTT：数据在信道传输的时间。</li>
<li>T<sub>A</sub>：接收方发送确认分组的时间。</li>
</ul>
<p>连续ARQ协议：</p>
<p>发送方维持一个发送窗口，可一次性发送窗口内的所有分组（流水线），不用一个一个等待确认。接收方采用累计确认的方式，对按序到达的最后一个分组发送确认，通过确认，发送方来移动发送窗口。</p>
<h1>TCP流量控制</h1>
<p>流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。</p>
<p>发送方的发送窗口不能超过接收方给出的接收窗口。</p>
<p>通过TCP首部中窗口值限制发送方的发送窗口大小，来实现流量控制。</p>
<p>TCP为每一个连接设有一个持续计时器，只要TCP连接的乙方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段，接受方收到探测报文段给出现在的窗口值。</p>
<h1>TCP拥塞控制</h1>
<p>拥塞控制时防止过多的数据注入到网络中，时网络中路由器或链路不至于过载，是一个全局性的过程。而流量控制往往是指点对点通行量的控制，是端到端的问题。</p>
<h3 id="慢开始与拥塞避免">慢开始与拥塞避免</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201123429370.png" alt="image-20231201123429370" style="zoom:50%;">
<p>发送方维持一个拥塞窗口，让自己的发送窗口等于拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度，动态变换。</p>
<p>慢开始是发送窗口由小到大逐渐增大拥塞窗口数值，每次两倍增加。同时还要设置慢开始的门限，防止拥塞窗口增长过大引起网络拥塞。</p>
<p>当增大慢开始的门限值，使用拥塞避免算法，成线性缓慢增长。</p>
<blockquote>
<p>当出现网络阻塞，门限值减半，同时拥塞窗口设置为1，执行慢开始算法。</p>
</blockquote>
<h3 id="快重传和快恢复">快重传和快恢复</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201124000551.png" alt="image-20231201124000551" style="zoom:50%;">
<blockquote>
<p>当出线网络阻塞，门限值减半，同时拥塞窗口设置为新的门限值，执行快恢复算法（拥塞串口值线性增长）。</p>
</blockquote>
<p>快重传算法要求接收方不要等待在自己发送数据时才进行捎带确认，而是立即发送确认，即使<strong>收到了失序的报文段也要立即发送对已收到的报文段的重复确认</strong>。</p>
<p>对收到三个连续对分组的确认，则立即重传该分组。</p>
<p>网络阻塞：采用慢开始算法。</p>
<p>三个超时重传确认：采用快重传算法。</p>
<h1>TCP连接管理</h1>
<h2 id="TCP连接">TCP连接</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201130152427.png" alt="image-20231201130152427" style="zoom:50%;">
<p>TCP连接建立采用三次握手机制。</p>
<ul>
<li>第一次：客户端发送连接请求报文，无应用层数据。$SYM=1,seq=x(随机)$。</li>
<li>第二次：服务器为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。$SYN=1,ACK=1,seq=y(随机),ack=x+1$。</li>
<li>第三次：客户端为该TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据。$ACK=1,seq=x+1,ack=y+1$。</li>
</ul>
<p>ack是确认号，seq是报文段的序号。</p>
<h2 id="TCP释放">TCP释放</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201130948457.png" alt="image-20231201130948457" style="zoom:50%;">
<p>TCP的连接释放需要4次握手。</p>
<ul>
<li>第一次：客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。$FIN=1,seq=u$。</li>
<li>第二次：服务器返回一个确认报文段，客户到服务器这个方向的连接就释放了，处于半关闭状态。$ACK=1,seq=v,ack=u+1$。</li>
<li>第三次：服务器发送完数据，就发出连接释放报文段，<strong>主动关闭</strong>TCP连接。$FIN=1,ACK=1,seq=w,ack=u+1$。</li>
<li>第四次：客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。$ACK=1,seq=u+1,ack=w+1$</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络章节总复习</title>
    <url>/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>计算机网络期末总复习知识点总结。</p>
<span id="more"></span>
<h1>第 1 章 概述</h1>
<h2 id="1-边缘部分与核心部分">1. 边缘部分与核心部分</h2>
<p>互联网按工作方式可划分为<strong>边缘部分</strong>和<strong>核心部分</strong>。<strong>主机</strong>在网络的边缘，作用是<strong>进行信息处理</strong>。<strong>路由器</strong>在网络的核心部分，其作用是<strong>按存储转发方式进行分组交换</strong>。</p>
<p>边缘部分工作方式：<strong>C/S方式（客户请求服务，服务器提供服务）和P2P方式（对等进行通信）</strong>。</p>
<p>核心部分工作方式：<strong>路由器连接网络，利用存储转发技术转发分组</strong>。</p>
<h2 id="2-分组交换">2. 分组交换</h2>
<p>分组交换采用存储转发技术，把一个报文划分为几个分组（数据段）再进行传送。每个数据段加上必要的控制信息组成首部后，构成已给分组。</p>
<h2 id="3-计算机网络性能指标">3. 计算机网络性能指标</h2>
<ol>
<li>
<p>速率</p>
<p>网络技术中速率指的是数据的传送速率，单位bit/s，即每秒传输多少位。当提到网络的速率，往往指的是额定速率，而并非网络实际运行的速率。</p>
</li>
<li>
<p>带宽</p>
<p>网络带宽是指单位时间内网络的某信道所能通过的“<strong>最高数据率</strong>”，即<strong>数据发送速率上限</strong>。带宽的单位就是数据率的单位bit/s。</p>
</li>
<li>
<p>吞吐量</p>
<p>表示单位时间内通过某个网络的<strong>实际数据量</strong>。</p>
</li>
<li>
<p>时延<br>
$$<br>
总时延=发送时延+传播时延+处理时延+排队时延<br>
$$<br>
发送时延是主机或路由器发送数据帧所需时间：<br>
$$<br>
发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}<br>
$$<br>
传播时延是电磁波在信道中传播一定的距离需要花费的时间：<br>
$$<br>
传播时延=\frac{信道长度(m)}{电磁波在信道上传播速率(m/s)}<br>
$$</p>
</li>
<li>
<p>时延带宽积<br>
$$<br>
时延带宽积=传播时延\times 带宽<br>
$$</p>
</li>
</ol>
<h2 id="4-网络协议">4. 网络协议</h2>
<p>网络协议即协议，是<strong>为了进行网络中数据交换而建立的规则</strong>。<strong>计算机网络的各层及其协议的集合称为网络的体系结构</strong>。</p>
<p>网络协议主要由三部分组成：</p>
<ul>
<li><strong>语法</strong>：数据与控制信息的结构或格式。</li>
<li><strong>语义</strong>：需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li><strong>同步</strong>：事件实现顺序的详细说明。</li>
</ul>
<h2 id="5-五层协议的体系结构">5. 五层协议的体系结构</h2>
<ol>
<li>
<p>应用层</p>
<p>应用层的任务是通过进程之间的交互来完成特定网络应用。应用程协议定义的是<strong>应用进程之间通信和交互的规则</strong>。</p>
<p>应用程协议：DNS、HTTP、SMTP等。应用层交互的数据单元称为<strong>报文</strong>。</p>
</li>
<li>
<p>运输层</p>
<p>运输层任务负责向<strong>两台主机中进程之间</strong>的通信提供<strong>通用的数据传输服务</strong>。</p>
<p>运输层协议：<strong>传输控制协议TCP</strong>，传输单元是<strong>报文段</strong>；用户数据报协议UDP，传输单元是<strong>用户数据报</strong>。</p>
</li>
<li>
<p>网络层</p>
<p>网络层负责为分组交换网上的<strong>不同主机</strong>提供服务。将运输层的数据单元封装成<strong>分组</strong>，也叫<strong>IP数据报</strong>。通过一定算法，生成转发分组的转发表，依据转发表中指明的路径将分组转发到一个路由器中。</p>
</li>
<li>
<p>数据链路层</p>
<p>将<strong>IP数据报</strong>组装成<strong>帧</strong>，每一帧包括数据和必要的控制信息，控制信息使得接收端正确接收帧，对帧尽心差错检测，改正数据。</p>
</li>
<li>
<p>物理层</p>
<p>物理层所传数据的单位是<strong>比特</strong>。</p>
</li>
</ol>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230914095817696.png" alt="image-20230914095817696" style="zoom:80%;">
<h2 id="6-TCP-IP体系结构">6. TCP/IP体系结构</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230914100004924.png" alt="image-20230914100004924" style="zoom:80%;">
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230914100047099.png" alt="image-20230914100047099" style="zoom:80%;">
<h2 id="7-实体、协议、服务和服务访问点">7. 实体、协议、服务和服务访问点</h2>
<ol>
<li>实体：任何可以发送或接收信息的硬件或软件进程。</li>
<li>协议：控制两个对等实体（或多个实体）进行通信的规则的集合。（水平的）</li>
<li>服务：下层向上层通过层间接口提供服务。（垂直的）</li>
<li>服务访问点：同一系统中相邻两层的实体进行交互的地方。</li>
</ol>
<p>协议必须把所有不利的条件事先都要估计到，不能假定一切都是正常的和非常理想的，必须非常仔细地检测协议能否应付任何一种出现概率极小的异常情况。<strong>提高协议面对异常情况的能力</strong>。</p>
<p><strong>协议控制本层向上层提供服务，本层协议的实现要使用下层提供的服务</strong>。</p>
<h1>第 2 章 物理层</h1>
<h2 id="1-物理层任务和特点">1. 物理层任务和特点</h2>
<p>物理层的主要任务是<strong>描述确定与传输媒介的接口有关的特性</strong>：</p>
<ol>
<li><strong>机械特性</strong>：指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的<strong>电压的意义</strong>。</li>
<li><strong>过程特性</strong>：指明对于不同功能的<strong>各种可能事件的出现顺序</strong>。</li>
</ol>
<h2 id="2-通信三种方式">2. 通信三种方式</h2>
<ol>
<li><strong>单工通信</strong>：只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>半双工通信</strong>：通信双方都可以发送消息，当不能双方同时发送或接收。</li>
<li><strong>全双工通信</strong>：通信双方可以同时发送和接收消息。</li>
</ol>
<h2 id="3-规程和协议的区别">3. 规程和协议的区别</h2>
<p>物理层的协议常称为规程，但协议泛指所有层上的协议。</p>
<h2 id="4-数据通信系统模型">4. 数据通信系统模型</h2>
<ol>
<li>
<p><strong>源系统</strong>：包括源点和发送器。</p>
<p>源点：源点设备产生要传输的数据。</p>
<p>发送器：源点生成的数字比特流通过发送器编码后在传输系统中进行传输。</p>
</li>
<li>
<p><strong>传输系统</strong></p>
</li>
<li>
<p><strong>目的系统</strong>：包括接收器和终点。</p>
<p>接收器：接收传输系统传送过来的信号，并转换为能够被目的设备处理的信息。</p>
<p>终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出。</p>
</li>
</ol>
<h2 id="5-基本名称概念">5. 基本名称概念</h2>
<ol>
<li>数据：运送消息的实体。</li>
<li>信号：数据的电气或电磁的表现。</li>
<li>模拟信号：连续信号。</li>
<li>数字信号：离散信号。</li>
<li>码元：代表数字信号不同离散值的基本波形。</li>
<li>基带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li>
<li>带通信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。（<strong>调频，调相，调幅</strong>）</li>
</ol>
<h2 id="6-信道复用技术">6. 信道复用技术</h2>
<ol>
<li>
<p><strong>频分复用</strong></p>
<p>把各路信号分别搬移到适当的频率位置，各路信号在同样时间占用不同的带宽资源。</p>
</li>
<li>
<p><strong>时分复用</strong></p>
<p>每一路信号占用固定序号的时隙，在不同时间占用同样的频带宽度。</p>
<p><strong>统计时分复用（STDM）</strong>：不固定分配时序，而是按需动态分配时隙。</p>
</li>
<li>
<p><strong>波分复用</strong></p>
<p>光的频分复用。</p>
</li>
<li>
<p><strong>码分复用</strong></p>
<p><strong>码分多址（CDMA）</strong>：用户同样的时间使用同样的频带进行通信，各用户使用不同码型，各用户之间不会造成干扰。</p>
<p><strong>码片</strong></p>
<ol>
<li>
<p>每一站有自己的唯一的一个码片序列，发送比特1，则发送它的 m bit码片序列，发送比特0，则发送该码片序列的反码。这个码片序列和其他任何一个站的码片序列向量积为 0。</p>
</li>
<li>
<p>每一个站有其他站的码片向量（码片序列），每个站点接收的信息是其他所有站发送的码片序列之和。</p>
</li>
<li>
<p>码片序列之和和站点拥有的其他站点码片序列依次进行规格化内积运算。如果规格化内积为1或-1，表示是对应站点发送了信息；如果是0，则对应站点没有发送信息。</p>
</li>
<li>
<p>规格化内积为1表示数据信息为比特1，如果是-1，表示为比特0。</p>
</li>
</ol>
</li>
</ol>
<h2 id="7-常用编码方式">7. 常用编码方式</h2>
<ol>
<li>不归零制：正<strong>电平</strong>代表 1，负电平代表 0。（有弱电流影响）</li>
<li>归零制：正<strong>脉冲</strong>代表 1，负脉冲代表0。</li>
<li>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。可以反过来定义。</li>
<li>差分曼彻斯特编码：在每一位的中心始终有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1。</li>
</ol>
<h2 id="8-传输媒介">8. 传输媒介</h2>
<ol>
<li>
<p>导引型传输媒介</p>
<p>双绞线：无屏蔽双绞线、有屏蔽双绞线；3类线、5类线。</p>
<p>同轴电缆：粗轴和细轴。</p>
<p>光纤：多模和单模（衰耗小）</p>
</li>
<li>
<p>非导引型传输媒介</p>
<p>无线、红外或大气激光。</p>
</li>
</ol>
<h1>第 3 章 数据链路层</h1>
<h2 id="1-数据链路和链路的区别">1. 数据链路和链路的区别</h2>
<ol>
<li>链路是从一个节点到相邻节点的一段<strong>物理线路</strong>，中间没有其他交换节点。</li>
<li>数据链路需要有一条物理线路，还必须有一些必要的通信协议控制数据传输。</li>
</ol>
<h2 id="2-数据链路层三个基本问题">2. 数据链路层三个基本问题</h2>
<h3 id="封装成帧">封装成帧</h3>
<p>把一段数据的前后分别添加首部和尾部，构成一个帧。首部和尾部的一个重要作用就是<strong>帧定界</strong>。区分分组的<strong>控制域和数据域</strong>，同时方便对数据进行差错检测。</p>
<h3 id="透明传输">透明传输</h3>
<p>帧开始和结束的标记使用专门的控制字符，为了避免传输数据部分出现的这些特殊字符干扰帧定界，通过某些处理方法避免错误识别发生。</p>
<p>一般有<strong>字节填充、字符填充</strong>（类似于转义字符）和<strong>零比特填充法</strong>（连续5个1出现则后面填充一个0）。</p>
<h3 id="差错检测">差错检测</h3>
<p>帧在传输过程中可能出现<strong>比特差错</strong>的问题。通过校验码或纠正码来对数据进行检测判断，保证数据争取传输。</p>
<p>采用<strong>循环冗余检测码CRC</strong>的检错技术。</p>
<p>循环冗余检测码的原理：给定一个<code>n+1</code>位除数，传输的原始数据后面补充<code>n</code>位0，然后开始做除法（二进制的除法是异或运算），最后计算出的<code>n</code>位余数（<strong>帧检验序列FCS</strong>）填充到之前<code>n</code>位0比特的位置，构成最后传给接受方的数据。接收方接收到发送的数据，用规定好的除数对数据进行验证，如果最终余数验证为0，则说明数据包没有出错。</p>
<h2 id="3-PPP协议">3. PPP协议</h2>
<p>点对点协议PPP是数据链路层使用最多的协议，特点是：简单，只检验差错，不纠正错误，不使用序号，也不进行流量控制，可同时支持多种网络层协议。</p>
<p>PPP协议不支持多点线路（一个主站轮流和链路上的多个站点进行通信），只支持点对点的链路通信。PPP协议只支持全双工通信。</p>
<p><strong>PPP协议组成</strong>：</p>
<ol>
<li>一个将IP数据报封装到串行链路的方法。</li>
<li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议LCP</strong>。</li>
<li>一套<strong>网络控制协议NCP</strong>，其中每一个协议支持不同的网络层协议。</li>
</ol>
<h3 id="PPP帧格式">PPP帧格式</h3>
<p><strong>PPP帧的首部和尾部分别为四个字段（6个字节）和两个字段（3个字节）</strong>。</p>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230926210550132.png" alt="image-20230926210550132" style="zoom:80%;">
<ol>
<li><code>F</code>：字段<code>7E</code>标志一个帧的开始和结束，帧的定界符。</li>
<li><code>A</code>和<code>C</code>：暂时没有进行定义来使用。</li>
</ol>
<p><strong>字节填充</strong></p>
<p>信息段的<code>7E</code>转变为<code>7D 5E</code>，信息字段的<code>7D</code>转化为<code>7D 5D</code>。</p>
<p><strong>零比特填充</strong></p>
<p>信息段每遇到5个连续的1就在后面插入1个0。</p>
<h3 id="PPP协议工作状态">PPP协议工作状态</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230926212309993.png" alt="image-20230926212309993" style="zoom:80%;">
<p>PPP协议共有6中工作状态：①链路静止，②链路建立，③鉴别，④网络层协议，⑤链路打开，⑥链路终止。</p>
<ol>
<li>
<p>用户个人电脑通过解调器呼叫路由器，双方建立物理连接，进入<strong>链路建立</strong>状态。</p>
</li>
<li>
<p>向链路另一端发送LCP的配置请求帧，经过双方协商后，建立LCP链路，进入<strong>鉴别</strong>状态。</p>
</li>
<li>
<p>向链路另一端发送鉴别的信息，若鉴别成功则进入<strong>网络协议状态</strong>，鉴别失败则进入<strong>链路终止</strong>状态。</p>
</li>
<li>
<p>网络协议状态，配置网络层协议，<strong>PPP链路两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组</strong>，配置完毕进入<strong>链路打开</strong>状态。</p>
</li>
<li>
<p>链路打开状态，PPP链路两端可以彼此发送分组。</p>
</li>
<li>
<p>数据传输结束后，链路一段发出终止请求，另一端收到终止确认，转到<strong>链路终止状态</strong>。</p>
</li>
<li>
<p>链路过程出现故障，也会从链路打开转到<strong>链路终止状态</strong>。</p>
</li>
<li>
<p>调制解调器的载波停止后，回到<strong>链路静止状态</strong>。</p>
</li>
</ol>
<h2 id="4-局域网">4. 局域网</h2>
<p>局域网的主要特点：<strong>网络为一个单位所拥有，且地理范围和站点数据均有限</strong>。</p>
<p>局域网的优点：</p>
<ol>
<li>具有广播功能，一个站点可以访问全网，局域网上主机之间共享各种硬件和软件资源。</li>
<li>便于系统的扩展和逐渐演变，各设备位置可灵活调制和改变。</li>
<li>提高系统的可靠性、可用性和生存性。</li>
</ol>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230927093105687.png" alt="image-20230927093105687" style="zoom:80%;">
<h2 id="5-共享媒体资源">5. 共享媒体资源</h2>
<ol>
<li>
<p>静态划分信道</p>
<p>频分复用，时分复用、码分复用等，划分信道代价高，不适用于局域网。</p>
</li>
<li>
<p>动态媒体接入控制</p>
<ul>
<li>随机接入：所有用户可随机地发送信息，但如果多用户同时发送消息，发送碰撞导致发送失败。</li>
<li>受控接入：必须服从一定地控制。分散控制地令牌局域网和集中控制地多点线路探寻。</li>
</ul>
</li>
</ol>
<h2 id="6-以太网">6. 以太网</h2>
<p>传统以太网：DIX Ethernet V2 标准的局域网。</p>
<p>以太网两个主要标准：DIX Ethernet V2标准和 IEEE 的 802.3 标准。</p>
<p>以太网通信采取两种措施：</p>
<ol>
<li><strong>无连接</strong>工作方式，不建立连接直接发送数据，对数据帧<strong>不进行编号</strong>，<strong>不要求对方发回确认</strong>。目的站接收到有差错的帧<strong>直接丢弃</strong>，其他什么都不做。</li>
<li>使用<strong>CSMA/CD协议</strong>，<strong>载波监听多点接入/碰撞检测</strong>。</li>
</ol>
<h2 id="7-适配器">7. 适配器</h2>
<p>计算机与外界局域网通信要通过适配器，又称为网络接口卡或网卡，<strong>计算机的硬件地址就是在适配器的ROM中</strong>。</p>
<p>适配器要进行数据串行传输和并行传输的转换，装有数据缓存的存储芯片，对数据帧进行差错检验后交给网络层。</p>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230927095008113.png" alt="image-20230927095008113" style="zoom:80%;">
<p>适配器有<strong>过滤</strong>功能：只接<strong>收单播帧、广播帧或多播帧</strong>。</p>
<p>适配器的<strong>混杂方式</strong>接收所有以太网上的帧。</p>
<h2 id="8-CSMA-CD协议">8. CSMA/CD协议</h2>
<ol>
<li><strong>多点接入</strong>：许多计算机以多点接入的方式连接在一根总线上。</li>
<li><strong>载波监听</strong>：边发送边监听。</li>
<li><strong>碰撞检测</strong>：适配器边发送数据边检测信道上的信号电压的变化情况，发送碰撞，总线上的信号电压变化幅度会增大（相互叠加）。</li>
</ol>
<p>一旦发送碰撞，就立即停止发送，按照退避算法等待一段随机时间后再次发送。</p>
<p>使用CSMA/CD协议，一个站<strong>不能同时发送消息和接收消息</strong>，<strong>只支持半双工通信</strong>。</p>
<p>假定端到端的传播时延即为$\tau$，最长经过$2\tau$的时间（<strong>争用期 $51.2\mu s$ 512比特时间</strong>）检测出发送碰撞。发送的数据帧不少于64个字节。</p>
<h2 id="9-集线器">9. 集线器</h2>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用CSMA/CD协议，同一时刻至多只允许一个站发送数据。</p>
<p><strong>在物理上是星形网，在逻辑上则是总线型。集线器工作在物理层上，每个端口只负责转发比特，不进行碰撞检测</strong>。</p>
<h2 id="10-MAC地址">10. MAC地址</h2>
<p><strong>硬件地址</strong>又称<strong>物理地址</strong>或<strong>MAC地址</strong>，固化在适配器的ROM中的地址。每个适配器的地址都不相同，48位长。</p>
<h3 id="MAC帧格式">MAC帧格式</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230928092329319.png" alt="image-20230928092329319" style="zoom:80%;">
<ul>
<li>类型字段：用来标识上一层使用的是什么协议。</li>
<li>FCS帧检验序列：检查范围是整个的MAC帧，从目的地址开始到FCS为止的五个阶段，不包括物理层插入的8字节的前同步码和帧开始定界符。</li>
<li>多插入的8个字节：前7个字节是接收端的适配器接收MAC帧时能够迅速调整其时间频率，使得时钟同步，最后1个字节是帧开始定界符。</li>
</ul>
<h2 id="11-以太网集线器和交换机带宽计算">11. 以太网集线器和交换机带宽计算</h2>
<ul>
<li>集线器：连接在集线器的站点之间共享集线器的带宽，<strong>集线器带宽平均分配给每个站点</strong>。</li>
<li>交换机：连接交换机每个站点可以同时进行发送和接口操作，（多端口网桥，全双工方式），每个站点的带宽就是交换机上的最大带宽。</li>
</ul>
<h2 id="12-以太网交换机自学习">12. 以太网交换机自学习</h2>
<ol>
<li>主机发送请求，会经过若干个路由器，路由器中有CAM表，记录每个主机的转发接口和MAC地址。如果发送一个请求，CAM表中没有该主机的转发接口和MAC地址等信息，则会记录学习。</li>
<li>在通过路由器进行转发时，会从CAM表中找目的主机的转发接口来进行数据包的转发。</li>
<li>如果目标主机地址找不到，路由器会指向广播操作，向所有转发接口进行数据转发（除了传输了该数据的转发接口）。</li>
<li>通过广播操作，期待接收目标主机发回响应，返回确认给源主机。</li>
</ol>
<h1>第 4 章 网络层</h1>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>期末考试</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度算法</title>
    <url>/2023/11/26/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>介绍一些进程调度上判断依据的概念和计算方式以及进程调度算法的说明。</p>
<span id="more"></span>
<h1>基本概念</h1>
<ul>
<li>
<p>完成时间：进程完成的时间。</p>
</li>
<li>
<p>周转时间：指进程从到达等待队列到完成执行的时间。<br>
$$<br>
T_i=作业i完成时间-作业i到达时间 \quad or \quad T_i=作业i执行时间+作业i等待时间<br>
$$</p>
</li>
<li>
<p>带权周转时间<br>
$$<br>
带权周转时间=\frac{周转时间}{实际执行时间}<br>
$$</p>
</li>
<li>
<p>平均周转时间<br>
$$<br>
平均周转时间=\frac{\sum_{i=1}^{n}作业_i周转时间}{n}<br>
$$</p>
</li>
<li>
<p>平均带权周转时间<br>
$$<br>
平均带权周转时间=\frac{\sum_{i=1}^{n}带权周转时间}{n}<br>
$$</p>
</li>
</ul>
<h1>调度算法</h1>
<h2 id="先来先服务调度算法">先来先服务调度算法</h2>
<ul>
<li>
<p>最简单的调度算法，先进入的队列的进程优先调度</p>
</li>
<li>
<p>非抢占式算法</p>
</li>
</ul>
<h2 id="短作业优先调度算法">短作业优先调度算法</h2>
<ul>
<li>每一次调度从预估运行时间最小的进程优先调度</li>
<li>非抢占式调度算法</li>
<li>和先来先服务调度算法相比，降低平局周转时间和平局带权周转时间</li>
<li>但是存在进程&quot;饿死&quot;问题，即一直有短作业进程进入队列，而长作业进程始终不能被调度</li>
</ul>
<h2 id="时间片轮转调度算法">时间片轮转调度算法</h2>
<ul>
<li>进程按到达系统时间的先后次序排队，按照先来先服务的规则调度进程，但是每个进程在处理机上运行规定好的一个时间片的时间，如果没有执行完，则将进程重新排队到就绪队列队尾。</li>
<li>如果进程在一个时间片上执行等待其他事件发生或资源，则将进程插到阻塞队列中，等所有资源拿到后在插入到就绪队列队尾。</li>
<li>抢占式调度算法。</li>
</ul>
<h2 id="高响应比优先调度算法">高响应比优先调度算法</h2>
<ul>
<li>
<p>非抢占式算法</p>
</li>
<li>
<p>在调度进程的时候统计计算响应比的值，来选择调度哪一个进程，计算公式如下：<br>
$$<br>
R_p=\frac{运行时间+等待时间}{运行时间}<br>
$$<br>
响应比大，优先调度。</p>
</li>
</ul>
<h2 id="优先级调度算法">优先级调度算法</h2>
<ul>
<li>
<p>静态优先级</p>
<p>进程创建时就定义一个优先级，之后整个生命周期优先级不在改变。</p>
<ol>
<li>简单、系统开销小</li>
<li>不灵活，优先级低的长时间得不到调度</li>
</ol>
</li>
<li>
<p>动态优先级</p>
<p>进入系统时根据某种规则赋予一个优先级，其后不断进行动态调整。</p>
<ol>
<li>灵活、资源利用率高</li>
</ol>
</li>
</ul>
<p>优先级调度算法分为抢占式和非抢占式两种。</p>
<p>抢占式指的是只有就绪队列中有比当前运行进程的优先级高的，运行进程被切换下来，运行优先高的进程。</p>
<p>非抢占式指的是当有优先级高的进程在队列中，当前运行的的进程不会切换下来，而是等它执行完。</p>
<p>抢占式适合对实时性要求高的系统，但是会增加系统进程切换的开销。</p>
<p>非抢占式适合批处理系统，只有线程完成或者等待资源才会从处理机上下来。</p>
<h2 id="多级反馈队列调度算法">多级反馈队列调度算法</h2>
<ul>
<li>
<p>有多个就绪队列，每个队列对应一个优先级。每个优先级队列分配的时间片不同，优先级越高，时间片长度越短。</p>
</li>
<li>
<p>新进程进入系统先放入最高优先队列Q1中，执行一个时间片的时间，如果没有执行完，则放入到下一个优先级的队列Q2的队尾。</p>
</li>
<li>
<p>仅当前面优先级高的几个队列为空，才能调度后面较低优先级队列中的进程。</p>
<p>当低优先级队列中进程上处理运行，如果此时高优先级队列中进入新进程，处理机采用抢占式策略，将当前运行进程切换下来，然后运行优先级高队列上的进程。</p>
<p>同优先级队列中的进程按照先来先服务的策略，不进行抢占。</p>
</li>
</ul>
<p>多级反馈队列调度算法能够满足段进程优先处理，系统开销小（长作业进程主要在低优先级队列中进行），能够同时支持分时，实时，批处理的通用操作系统。还是存在较低队列中进程长时间得不到运行，导致&quot;饥饿&quot;。</p>
<h1>解题方法</h1>
<p>对于进程调度求解可以进行画图的形式来做题。例题：</p>
<p><img src="/2023/11/26/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20231127150238829.png" alt="image-20231127150238829"></p>
<img src="/2023/11/26/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20231127151608032.png" alt="image-20231127151608032" style="zoom:70%;">
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>处理机</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用语法</title>
    <url>/2023/12/03/MySQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>MySQL增删改查，多表查询，视图，存储过程，存储函数，游标。</p>
<span id="more"></span>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constraint 外键名称 foreign key 外键字段名 references 主表(列名)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表 (主表列名);</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ol>
<li><p>创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index index_name on table_name (index_col_name, ...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_name on table_name;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ol>
<li><p>创建视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view view_name as select语句</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看视图语句</span><br><span class="line">show create view view_name;</span><br><span class="line"># 查看视图数据</span><br><span class="line">select * from view_name ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [or replace] view view_name as select语句;</span><br><span class="line">alter view view_name as select语句;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop view [if exists] view_name ...;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><ol>
<li><p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名称([[in or out]参数列表])</span><br><span class="line">begin</span><br><span class="line"> -- SQL语句</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 名称 ([参数]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop procedure [if exists] procedure_name ...;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>作为输入</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>作为输出，返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>即可作为输入参数也可作为输出参数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li><p>查看系统变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量</span><br><span class="line">SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#x27;......&#x27;; -- 可以通过LIKE模糊匹配方式查找变量</span><br><span class="line">SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置系统变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;</span><br><span class="line">SET @@[SESSION | GLOBAL] 系统变量名 = 值 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户自定义变量赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @var_name = expr [, @var_name = expr] ... ;</span><br><span class="line">SET @var_name := expr [, @var_name := expr] ... ;</span><br><span class="line"></span><br><span class="line">SELECT @var_name := expr [, @var_name := expr] ... ;</span><br><span class="line">SELECT 字段名 INTO @var_name FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义变量使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @var_name</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>局部变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 声明</span><br><span class="line">declare 变量名 变量类型 [default ...];</span><br><span class="line"></span><br><span class="line"># 赋值</span><br><span class="line">set 变量名 = 值;</span><br><span class="line">set 变量名 := 值;</span><br><span class="line">select 字段名 into 变量名 from 表名 ...;</span><br></pre></td></tr></table></figure>
<h2 id="条件-循环语句"><a href="#条件-循环语句" class="headerlink" title="条件/循环语句"></a>条件/循环语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件 then</span><br><span class="line">	...</span><br><span class="line">elseif 条件2 then</span><br><span class="line">	...</span><br><span class="line">else</span><br><span class="line">	...</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line">	-- SQL逻辑</span><br><span class="line">end while;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">    SQL逻辑...;</span><br><span class="line">    UNTIL 条件</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	SQL逻辑...</span><br><span class="line">END LOOP [end_label];</span><br><span class="line"></span><br><span class="line">LEAVE label; -- 退出指定标记的循环体</span><br><span class="line">ITERATE label; -- 直接进入下一次循环</span><br></pre></td></tr></table></figure>
<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><ol>
<li><p>声明游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare 游标名称 cursor for 查询语句;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>打开游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open 游标名称;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>获取游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch 游标 into 变量 [, 变量 ...];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>关闭游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">close 游标名称;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p8()</span><br><span class="line">begin</span><br><span class="line">    declare t_index char(6);</span><br><span class="line">    declare price float;</span><br><span class="line">    declare flag bool default true;</span><br><span class="line">    declare cur_update cursor for</span><br><span class="line">        (select goods.goodsno, goods.saleprice from goods join category c on c.categoryno = goods.categoryno where c.categoryno = &#x27;cn001&#x27;);</span><br><span class="line">    declare continue handler for not found set flag := false;</span><br><span class="line"></span><br><span class="line">    open cur_update;</span><br><span class="line">    while flag do</span><br><span class="line">        fetch cur_update into t_index, price;</span><br><span class="line">        update goods set saleprice = price * 0.9 where goodsno = t_index;</span><br><span class="line">    end while;</span><br><span class="line">    close cur_update;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>MySQL游标的关闭是通过处理异常来关闭的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare continue handler for not found set flag := false;</span><br></pre></td></tr></table></figure>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表相关的数据库对象，指在<code>insert/update/delete</code>之前<code>before</code>或之后<code>after</code>，触发并执行触发器中定义的SQL语句。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>OLD 表示修改之前的数据，NEW表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger trigger_name</span><br><span class="line">before/after insert/update/delete</span><br><span class="line">on tb1_name for each row -- 行级触发器</span><br><span class="line">begin</span><br><span class="line">	-- SQL执行</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show triggers;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop trigger trigger_name;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger supplier_delete_trigger</span><br><span class="line">    before delete on supplier for each row</span><br><span class="line">begin</span><br><span class="line">    delete from salebill where salebill.goodsno in</span><br><span class="line">           (select g.goodsno from goods g join supplier s on g.supplierno = s.supplierno where s.supplierno = OLD.supplierno);</span><br><span class="line">    delete from goods where goods.supplierno = OLD.supplierno;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL常用命令</tag>
      </tags>
  </entry>
</search>
