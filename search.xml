<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言多线程编程 (一)</title>
    <url>/2023/11/25/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/</url>
    <content><![CDATA[<p>简单说明和使用C语言在window操作系统下创建多线程实现简单的示例操作。</p>
<span id="more"></span>
<h2 id="创建进程">创建进程</h2>
<p>使用的是<code>windows.h</code>提供的创建进程函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start_caculator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwExitCode;</span><br><span class="line">	PROCESS_INFORMATION	pi;</span><br><span class="line">	DWORD ret;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="built_in">sizeof</span>(si) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;calc.exe&quot;</span>;</span><br><span class="line">	<span class="comment">// 启动计算机</span></span><br><span class="line">	<span class="comment">// C++不能字符串转换 修改工程属性 项目属性-&gt;高级-&gt;字符集-&gt;使用Unicode字符集改为未设置</span></span><br><span class="line">	ret = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, s, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="comment">// 等待子进程的退出</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);</span><br><span class="line">		<span class="comment">// 关闭子进程的主线程语句</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">		<span class="comment">// 获取子进程的退出码</span></span><br><span class="line">		<span class="built_in">GetExitCodeProcess</span>(pi.hProcess, &amp;dwExitCode);</span><br><span class="line">		<span class="comment">// 关闭子进程句柄</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n进程结束 退出码是&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要的是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, s, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>lpApplicationName: 指定要运行的可执行文件的名称。在这种情况下，使用NULL表示使用命令行参数中指定的可执行文件</li>
<li><strong>lpCommandLine: 指定要传递给可执行文件的命令行参数。在这种情况下，使用字符串变量s作为命令行参数。</strong></li>
<li>lpProcessAttributes: 指定新进程的安全描述符。在这种情况下，使用NULL表示使用默认的安全描述符。</li>
<li>lpThreadAttributes: 指定新线程的安全描述符。在这种情况下，使用NULL表示使用默认的安全描述符。</li>
<li>bInheritHandles: 指定是否继承父进程的句柄。在这种情况下，使用FALSE表示不继承句柄。</li>
<li>dwCreationFlags: 指定控制新进程创建方式的标志。在这种情况下，使用0表示默认创建方式。</li>
<li>lpEnvironment: 指定新进程的环境块。在这种情况下，使用NULL表示使用父进程的环境块。</li>
<li>lpCurrentDirectory: 指定新进程的当前工作目录。在这种情况下，使用NULL表示使用父进程的当前工作目录。</li>
<li><strong>lpStartupInfo: 指向一个STARTUPINFO结构，该结构包含了新进程的一些属性，例如窗口显示方式、标准输入输出重定向等。在这种情况下，使用si结构体。</strong></li>
<li><strong>lpProcessInformation: 指向一个PROCESS_INFORMATION结构，该结构接收新进程的标识信息，例如进程句柄和线程句柄。在这种情况下，使用pi结构体。</strong></li>
</ul>
<p>这里运行会打开计算机，当时主进程会直接结束，计算器仍保留。</p>
<blockquote>
<p>疑问：这里主进程是等待子进程结束才会结束，而这个子进程是计算器本身这个进程，还是只开启计算器的进程？</p>
<p>个人理解是：IpCommandLine是传递命令参数，可能我们自己开启的进程的任务只是开启进程而不是计算器运行本身这个进程。</p>
</blockquote>
<h2 id="创建线程">创建线程</h2>
<p>定义线程结构体和启动线程两部分最重要。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hTread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, create_thread_task1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>线程使用的是<code>&lt;process.h&gt;</code>头文件。</p>
<p>第三个参数是传递线程执行函数的函数指针。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> WINAPI <span class="title">create_thread_task1</span><span class="params">(LPVOID paramter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;child thread running ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread_example_run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 句柄声明定义</span></span><br><span class="line">	<span class="comment">// _beginthreadex()函数创建一个新的线程 指定子线程执行函数指针(函数类型固定) 返回线程的句柄</span></span><br><span class="line">	HANDLE hTread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, create_thread_task1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;main thread running ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 句柄可以访问线程中各种系统资源 标识对象 访问对象 资源管理</span></span><br><span class="line">	<span class="comment">// 通过CloseHandle函数关闭线程句柄 释放资源</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hTread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里线程执行的函数是固定的定义方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> WINAPI <span class="title">xxx</span><span class="params">(LPVOID paramter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LPVOID paramter</code>：可以接收参数，通过创建线程执行语句的第4个参数</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;参数<span class="number">1</span>：指定线程安全特性 null 表示使用默认的安全特性</span><br><span class="line">&gt;参数<span class="number">2</span>：指定线程的堆栈大小 通常设置为<span class="number">0</span> 表示使用默认堆栈大小</span><br><span class="line">&gt;参数<span class="number">3</span>：指向线程函数的指针</span><br><span class="line">&gt;参数<span class="number">4</span>：传递给线程函数的参数 可以是任意类型的指针 接收是 <span class="type">void</span>* 类型</span><br><span class="line">&gt;参数<span class="number">5</span>：指定线程初始化标志 通常设置为<span class="number">0</span></span><br><span class="line">&gt;参数<span class="number">6</span>：用于接收新线程的标识符</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="线程其他相关命令">线程其他相关命令</h2>
<ul>
<li>主线程等待子线程结束语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前线程的ID</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GetCurrentThreadId</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>对于多个线程的处理，需要依次关闭线程，示例代码如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_multi_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE handles[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 依次开启多个线程</span></span><br><span class="line">		handles[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, thread_task3, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">10</span>, handles, TRUE, INFINITE);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main thread ending ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 依次关闭多个线程</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(handles[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主线程等待所有子线程结束</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForMultipleObjects</span>(<span class="number">3</span>, handles, TRUE, INFINITE);</span><br></pre></td></tr></table></figure>
<h2 id="补充知识">补充知识</h2>
<p>函数指针和函数指针数组，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task21</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"># 函数指针数组</span><br><span class="line"><span class="built_in">void</span> (*tasks[<span class="number">3</span>])() = &#123; thread_task1, thread_task2, thread_task3 &#125;;</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">tasks[i]();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言多线程编程 (二)</title>
    <url>/2023/11/28/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/</url>
    <content><![CDATA[<p>C语言实现线程的之间的同步和互斥，通过临界区、互斥量、事件、信号量实现线程的同步互斥，同时讲解一下进程之间的同步互斥。</p>
<span id="more"></span>
<h1>临界区实现同步互斥</h1>
<ol>
<li>
<p>首先我们要声明一个临界区的变量，利用临界区变量来实现临界区。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION global_cirtical_sectioin;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用临界区变量需要先初始临界区变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>进入临界区，利用临界区变量上锁。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>出临界区，解锁。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用结束后，删除临界变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;global_cirtical_sectioin);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完成的使用流程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRITICAL_SECTION global_cirtical_sectioin;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> WINAPI <span class="title">thread_task</span><span class="params">(LPVOID paramter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;global_thread_parameter);</span><br><span class="line">	<span class="comment">// 临界区代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 出临界区   </span></span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;global_thread_parameter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_zone_synchronization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hThread[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 初始化临界区变量</span></span><br><span class="line">	<span class="built_in">InitializeCriticalSection</span>(&amp;global_thread_code);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		hThread[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, thread_task, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">5</span>, hThread, TRUE, INFINITE);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hThread[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DeleteCriticalSection</span>(&amp;global_thread_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的临界区的设置，只允许同一时间只有一个线程能够执行临界区代码。</p>
<h1>互斥量实现同步互斥</h1>
<p>大致步骤和临界区相同。</p>
<ol>
<li>
<p>初始化互斥量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE mutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><code>CreateMutex</code>的作用是找出当前系统是否存在指定进程的示例，如果没有则创建一个互斥体。</p>
<ul>
<li>互斥对象是系统内核维护的一种数据结构，保证对象对单个线程的访问权。</li>
<li>互斥对象结构包括：使用数量（多少个线程调用该对象），线程ID（互斥对象的维护线程ID），计数器（当前线程调用该对象的次数）。</li>
<li>参数说明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateMutexA</span>(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, <span class="comment">// 指向安全属性的指针</span></span><br><span class="line">    _In_ BOOL bInitialOwner, <span class="comment">// 初始化互斥对象的所有者 如果为 TRUE 表示互斥量为创建线程所有</span></span><br><span class="line">    _In_opt_ LPCSTR lpName <span class="comment">// 指向互斥对象名的指针</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待互斥量被触发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(mutex, INFINITE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发互斥量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReleaseMutex</span>(mutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销互斥量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(mutex);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>事件实现同步互斥</h1>
<ol>
<li>
<p>初始化事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE event = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes, 	<span class="comment">// 安全属性结构体指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bManualReset,      	<span class="comment">// 是否手动复位</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL                  bInitialState,    	<span class="comment">// 初始状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR               lpName             	<span class="comment">// 事件名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lpEventAttributes</code>：一个指向SECURITY_ATTRIBUTES结构体的指针，用于设置事件对象的安全属性。如果该参数为NULL，则事件对象会继承调用进程的安全属性。</li>
<li><code>bManualReset</code>：一个布尔值，用于指定事件对象的类型。如果该参数为TRUE，则表示创建的是手动复位事件对象；如果该参数为FALSE，则表示创建的是自动复位事件对象。手动复位事件对象必须通过调用<code>ResetEvent</code>函数来将事件状态复位（即重置为未激发状态）；而自动复位事件对象则会在有信号触发时自动将其状态复位。</li>
<li><code>bInitialState</code>：一个布尔值，用于指定事件对象的初始状态。如果该参数为TRUE，则表示在创建事件对象时立即将其设置为已激发状态（signaled）；如果该参数为FALSE，则表示事件对象初始状态为未激发状态（nonsignaled）。</li>
<li><code>lpName</code>：一个字符串指针，用于指定事件对象的名称。如果该参数为NULL，则表示创建一个无名事件对象；否则表示创建命名的事件对象。需要注意的是，如果同时存在同名的命名事件对象，则会返回该事件对象的句柄。</li>
</ul>
</li>
<li>
<p>等待事件发生</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(event, INFINITE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SetEvent</span>(event);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(event);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>信号量同步</h1>
<ol>
<li>
<p>初始化信号量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前0个资源、最大允许1个同时访问</span></span><br><span class="line">HANDLE semaphore = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待$信号量&gt;1$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(semaphore, INFINITE);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>释放一个资源，信号量加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReleaseSemaphore</span>(semaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>撤销信号量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CloseHandle</span>(semaphore);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>进程之间互斥信号量实现互斥</h1>
<p>和线程之间原理一样，这里多了一步需要打开互斥对象，互斥对象有操作内核管理，通过名称查找到。</p>
<p>互斥对象存在时，同名的进程时不能运行的。</p>
<ol>
<li>
<p>创建互斥量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, TRUE, MUTEX_NAME);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打开互斥量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hMutex = <span class="built_in">OpenMutex</span>(MUTEX_ALL_ACCESS, TRUE, MUTEX_NAME);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发互斥量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等待互斥量触发</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>存在问题</h1>
<h2 id="WaitForSingleObject">WaitForSingleObject()</h2>
<p><code>WaitForSingleObject</code>函数的执行流程如下：</p>
<ol>
<li>线程调用<code>WaitForSingleObject</code>函数并传入需要等待的对象的句柄以及等待时间的长度。</li>
<li>系统检查对象的当前状态：
<ul>
<li>如果对象已经是 signaled 状态（已激发），则直接返回<code>WAIT_OBJECT_0</code>，线程可以继续执行后续操作。</li>
<li>如果对象不是 signaled 状态（未激发），则线程进入等待状态，并将该线程从可执行状态转换为等待状态，直到以下三种情况之一发生：
<ul>
<li>对象被激发，即对象状态变为 signaled。此时，线程会被唤醒，并返回<code>WAIT_OBJECT_0</code>，线程可以继续执行后续操作。</li>
<li>等待超时，即指定的等待时间到达。此时，线程会被唤醒，并返回<code>WAIT_TIMEOUT</code>，线程可以根据需要进行相应处理。</li>
<li>等待的对象被放弃。这通常出现在使用互斥体时，当互斥体的所有者线程意外终止而没有正确释放互斥体时，其他线程在等待该互斥体时会返回<code>WAIT_ABANDONED</code>。</li>
</ul>
</li>
</ul>
</li>
<li>线程根据返回值进行相应的处理。</li>
</ol>
<h2 id="不同线程之间临界区和互斥量不起作用">不同线程之间临界区和互斥量不起作用</h2>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>同步互斥</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建</title>
    <url>/2023/11/25/create_blog/</url>
    <content><![CDATA[<p>主要介绍一个初始博客的搭建和简单next主题的配置和遇到的问题，采用git + github + hexo + hexo next主题实现的一个个人博客网站。</p>
<span id="more"></span>
<h2 id="工具准备">工具准备</h2>
<p>下载git，参考网址：<a href="https://juejin.cn/post/7086817870172782623">图文详解 Git 安装【当前最新，最详细版】 - 掘金 (juejin.cn)</a></p>
<p>下载node.js，参考网址：<a href="https://juejin.cn/post/7090056744549744676">node.js安装及环境配置 - 掘金 (juejin.cn)</a></p>
<p>然后打开git bash命令窗口输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="github创建仓库">github创建仓库</h3>
<ol>
<li>
<p>自己注册一个账号，开始创建仓库，可以参考<a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p>需要注意的是仓库名称<code>xxx.github.io</code>。</p>
</li>
<li>
<p>在git上配置远程连接SSH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -global user.name &quot;用户名&quot;</span><br><span class="line">git config -global user.email &quot;邮箱&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成SSH密钥</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>生成结果：</p>
<p>路径<code>C:\Users\电脑用户名\.ssh\id_rsa.pub</code></p>
<p><img src="/2023/11/25/create_blog/image-20231125201927788.png" alt="image-20231125201927788"></p>
<p><img src="/2023/11/25/create_blog/image-20231125202103556.png" alt="image-20231125202103556"></p>
</li>
<li>
<p>将密钥全部复制粘贴到GitHub上</p>
<p><img src="/2023/11/25/create_blog/image-20231125202323393.png" alt="image-20231125202323393"></p>
</li>
</ol>
<h2 id="初始hexo项目">初始hexo项目</h2>
<h3 id="初始创建">初始创建</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure>
<p>下载next主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:theme-next/hexo-theme-next.git  ./themes/next</span><br></pre></td></tr></table></figure>
<p>更改根目录下的<code>_config.yml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">themes:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>然后执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取仓库内容</span></span><br><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译运行 本地测试</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载hexo-devloper</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>将根目录下<code>.config.yml</code>配置文件修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="comment"># https://xxx.github.io</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># https://gitee.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>配置修改后执行：（一定要先修改配置文件后在进行提交）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>执行上述所有步骤后，就可以通过github看到一个初始状态的个人博客了。</p>
<h2 id="Next主题配置">Next主题配置</h2>
<h3 id="选择主题">选择主题</h3>
<p>主题配置文件下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<p>可以自行选择四种样式。</p>
<h3 id="修改博客头像">修改博客头像</h3>
<p>在<code>themes/next/source/images</code>放入设置的图片。</p>
<img src="/2023/11/25/create_blog/image-20231125150218977.png" alt="image-20231125150218977">
<p>在主题配置文件中设置路径即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="侧边栏社交添加">侧边栏社交添加</h3>
<p>主题配置文件夹下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com || fab fa-github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure>
<h3 id="添加菜单结构">添加菜单结构</h3>
<p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>这样就可以创建一个tags目录，效果如图所示：</p>
<p><img src="/2023/11/25/create_blog/image-20231125135239747.png" alt="image-20231125135239747"></p>
<p>同理还可以创建<code>about、categories、archives</code>等菜单文件。</p>
<p>我们需要进入到每个文件目录下面去修改它<code>index.md</code>文件，修改它的类型，如图所示：</p>
<p><img src="/2023/11/25/create_blog/image-20231125135911341.png" alt="image-20231125135911341"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">tags: tags</span><br><span class="line">categories: categories</span><br><span class="line">留言板: 将comments一栏改为true type改为guestbook</span><br></pre></td></tr></table></figure>
<p>在主题的配置文件<code>_config.yml</code>开启对应菜单：</p>
<p><img src="/2023/11/25/create_blog/image-20231125140353312.png" alt="image-20231125140353312"></p>
<p>可以设置显示数量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="添加搜索功能">添加搜索功能</h3>
<p>下载搜索插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>主题目录下配置文件<code>_config.yml</code>开启本地搜索：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>根目录下<code>_config.yml</code>配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="添加动态背景">添加动态背景</h3>
<p>打开生成的hexo目录<code>\themes\next\layout\_layout.swig</code>文件，将代码放在<code>&lt;/body&gt;</code>上面。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">% if theme.canvas_nest %&#125;</span></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;<span class="comment">% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>主题配置文件添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># background settings</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># add canvas-nest effect</span></span><br><span class="line"><span class="comment"># see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="增加阅读时间和文章数字统计">增加阅读时间和文章数字统计</h3>
<p>下载插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>
<p>根目录下配置文件添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span>    </span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>
<p>主题配置文件下打开开关：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="部件配置">部件配置</h3>
<p>都在主题配置文件下</p>
<p>阅读进度条：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure>
<p>左上角Github图标：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/xxx</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>
<p>开启代码复制：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure>
<p>文末尾版权说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>
<p>设置回到顶部</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># Back to top in sidebar.</span></span><br><span class="line"> <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line"> <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"> <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="问题">问题</h2>
<h3 id="图片不显示">图片不显示</h3>
<p>hexo生成后图片路劲发生改变，导致了生成后文章找不到图片。</p>
<p>下载插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>修改根目录下配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>生成的时候可能要等一会，多刷新几次。</p>
<p>只有md文档同级下有对应文件夹来放图片就可以了。</p>
<p>如果还是不行，直接去修改<code>hexo-asset-image</code>包下的<code>index.js</code>文件：</p>
<p><img src="/2023/11/25/create_blog/image-20231125182910235.png" alt="image-20231125182910235"></p>
<p>去调整<code>index.js</code>的中路径字符串拼接的部分，视自己当前问题来合理调整。</p>
<p><strong>这里还需要注意的是根目录下的配置文件中<code>url</code>的配置：一定要是自己的仓库名，不然所有组件都会加载失败。</strong></p>
<h3 id="hexo的不支持Latex语法">hexo的不支持Latex语法</h3>
<p>我们需要进行重新选择插件进行渲染。</p>
<p>需要重新更新插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>修改主题配置文件：</p>
<img src="/2023/11/25/create_blog/image-20231127152223788.png" alt="image-20231127152223788" style="zoom:80%;">
<p>修改插件文件，路径<code>\blog\node_modules\kramed\lib\rules\inline.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inline = &#123;</span><br><span class="line">  <span class="comment">// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line">  <span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line">  <span class="attr">autolink</span>: <span class="regexp">/^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/</span>,</span><br><span class="line">  <span class="attr">url</span>: noop,</span><br><span class="line">  <span class="attr">html</span>: <span class="regexp">/^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;/</span>,</span><br><span class="line">  <span class="attr">link</span>: <span class="regexp">/^!?\[(inside)\]\(href\)/</span>,</span><br><span class="line">  <span class="attr">reflink</span>: <span class="regexp">/^!?\[(inside)\]\s*\[([^\]]*)\]/</span>,</span><br><span class="line">  <span class="attr">nolink</span>: <span class="regexp">/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/</span>,</span><br><span class="line">  <span class="attr">reffn</span>: <span class="regexp">/^!?\[\^(inside)\]/</span>,</span><br><span class="line">  <span class="attr">strong</span>: <span class="regexp">/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/</span>,</span><br><span class="line">  <span class="comment">// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">  <span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line">  <span class="attr">code</span>: <span class="regexp">/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/</span>,</span><br><span class="line">  <span class="attr">br</span>: <span class="regexp">/^ &#123;2,&#125;\n(?!\s*$)/</span>,</span><br><span class="line">  <span class="attr">del</span>: noop,</span><br><span class="line">  <span class="attr">text</span>: <span class="regexp">/^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/</span>,</span><br><span class="line">  <span class="attr">math</span>: <span class="regexp">/^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后重新生成运行就可以了。</p>
<h3 id="markdown不支持上标和下标的语法">markdown不支持上标和下标的语法</h3>
<p>使用html来实现上下标，不使用<code>~~和^^</code>。</p>
]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>BLOG</tag>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              主要说明网络层IP层的基本概念和相关协议，以及协议的工作流程等基本理论知识。</p>
<span id="more"></span>
<h1>基本概念</h1>
<ul>
<li>网络的工作主要就是对IP协议的基本内容。</li>
<li>网络层不提供服务质量保证，有运输层来保证。</li>
</ul>
<p>网络连接设备：</p>
<ol>
<li>物理层：转发器</li>
<li>数据链路层：网桥、交换机</li>
<li>网络层：路由器</li>
<li>网关：网络层</li>
</ol>
<h1>网际协议IP</h1>
<p>网际协议IP配套使用三种协议：</p>
<ul>
<li>地址解析协议（ARP）</li>
<li>网际控制报文协议（ICMP）</li>
<li>网际组管理协议（IGMP）</li>
</ul>
<h2 id="IP地址">IP地址</h2>
<p><strong>全球范围唯一的32位标识符</strong></p>
<p><img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129164207215.png" alt="image-20231129164207215"></p>
<h3 id="分类的IP地址">分类的IP地址</h3>
<p>分为A、B、C、D、E类地址。</p>
<ul>
<li>A（8位）、B（16位）、C（24位）类是单播地址，最常用</li>
<li>D类是多播地址（一对多通信）</li>
<li>E类是保留地址</li>
</ul>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129164502642.png" alt="image-20231129164502642" style="zoom:80%;">
<h4 id="不指派的IP">不指派的IP</h4>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129165910304.png" alt="image-20231129165910304" style="zoom:80%;">
<p>主要是注意全0表示位网络的网络号，全1表示该网络的广播地址。</p>
<h3 id="无分类编址CIDR">无分类编址CIDR</h3>
<p><code>/</code>后的数字来指定网络前缀，以此确定网络号</p>
<p><img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129165624467.png" alt="image-20231129165624467"></p>
<p>斜线后面的数字就是地址掩码中1的个数。</p>
<ul>
<li>前缀n =32，即32位IP 地址都是前缀，没有主机号。这其实就是一个IP 地址。这个特殊地址用于主机路由。</li>
</ul>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129170621284.png" alt="image-20231129170621284" style="zoom:80%;">
<p>同一局域网中主机的网络前缀相同。</p>
<h4 id="划分子网">划分子网</h4>
<h2 id="IP地址与MAC地址">IP地址与MAC地址</h2>
<p>MAC地址成为硬件地址或物理地址。</p>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129170944235.png" alt="image-20231129170944235" style="zoom:80%;">
<ul>
<li>IP 地址放在 IP 数据报的首部。</li>
<li>MAC 地址则放在 MAC 的首部。</li>
<li>在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是 MAC 地址。</li>
<li>当IP数据报插入到数据链路层的 MAC 以后，整个的IP数据报就成为 MAC的数据，因而在数据链路层看不见数据报的IP地址。</li>
</ul>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129171408560.png" alt="image-20231129171408560" style="zoom:80%;">
<ol>
<li>
<p>在IP层抽象的互联网上只能看到IP数据报，在数据包传送过程中<strong>IP的源地址和目的地址始终不变</strong>。</p>
</li>
<li>
<p>路由器只根据目的站的IP地址进行转发。</p>
</li>
<li>
<p>在不同网络上传送时，其MAC首部中的源地址和目的地址要发生变化。</p>
<p>如图所示，开始在H到间传送时，MAC首部中写的是从MAC地址MAC<sub>1</sub>发送到MAC<sub>3</sub>地址。路由器R<sub>1</sub>收到此MAC后，在数据链路层，要剥去原来的MAC的首部和尾部。在转发时，在数据链路层，要重新添加上MAC的首部和尾部。这时首部中的源地址和目的地址分别变成为MAC<sub>4</sub>和MAC<sub>5</sub>。</p>
</li>
</ol>
<h1>地址解析协议ARP</h1>
<p>地址解析协议ARP主要是为了解决主机<strong>通过IP地址找到相应的MAC地址</strong>。</p>
<p>在主机的<strong>ARP高速缓冲</strong>存放从IP地址到MAC地址的映射表，映射表动态更新。</p>
<h2 id="工作流程">工作流程</h2>
<p>主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的MAC地址，再把这个MAC地址写入MAC，然后通过局域网把该MAC发往此MAC地址。</p>
<p>如果没有则执行以下步骤：</p>
<ol>
<li>ARP进程在本局域网上<strong>广播</strong>发送一个ARP请求分组</li>
<li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</li>
<li>主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址</li>
<li>其余所有主机的IP地址都与ARP请求分组中要查询的P地址不一致，因此都不理睬这个ARP请求分组。</li>
<li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射。</li>
</ol>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129211609859.png" alt="image-20231129211609859" style="zoom:80%;">
<ul>
<li>发送方是主机(如H<sub>1</sub>)，要把IP数据报发送到同一个网络上的另一台主机(如H<sub>2</sub>)。这时H<sub>1</sub>发送ARP请求分组(在网络N<sub>1</sub>上广播)，找到目的主机H<sub>2</sub>的MAC地址。</li>
<li>发送方是主机(如H<sub>1</sub>)，要把IP数据报发送到另一个网络上的一台主机(如 H<sub>3</sub>或H<sub>4</sub>)。这时H<sub>1</sub>发送ARP请求分组(在网络N<sub>1</sub>上广播)，找到上的一个路由器R<sub>1</sub>的MAC地址。</li>
<li>发送方是路由器(如R<sub>1</sub>，要把IP数据报转发到与连接在同一个网络N<sub>2</sub>上的主机(如H<sub>3</sub>)。这时R发送ARP请求分组(在N<sub>2</sub>上广播)，找到目的主机H<sub>3</sub>的MAC地址。</li>
<li>发送方是路由器(如R<sub>1</sub>)，要把IP数据报转发到网络N<sub>3</sub>的一台主机(如H<sub>4</sub>），H<sub>4</sub>与R<sub>1</sub>不是连接在同一个网络上的。这时R<sub>1</sub>发送ARP请求分组(在N<sub>2</sub>上广播)，找到连接在N<sub>3</sub>上的一个路由器R<sub>2</sub>的MAC地址。</li>
</ul>
<h1>IP数据报格式</h1>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129212448388.png" alt="image-20231129212448388" style="zoom:80%;">
<p>首部宽度32位（4字节），IP数据报由首部和数据部分两部分组成。</p>
<ul>
<li>
<p><strong>首部长度：占4位，能够表示最大十进制为15，表示单位是32位字长（4字节），也就是说首部最长为$15\times4=60$个字节</strong>。</p>
<p>IP首部固定是20个字节，也就是前四排，第五排是可选字段，通过首部长度可以算出可选字段的长度。</p>
<p>首部长度长度单位是32位字长（4字节），所以首部长度一定是4字节整数倍，不足用填充字段补充。</p>
</li>
<li>
<p>总长度：指整个IP数据报的长度，通过和首部长度计算出数据部分的长度。</p>
<p>IP数据报长，能够提高传输效率。数据报短，路由转发速度快，各有好处。</p>
<p><strong>但以太网规定最大的传输单元MTU是1500字节，如果IP数据报过长，需要对数据报进行分片处理</strong>。</p>
</li>
<li>
<p>标志：占3位，只有两位有意义。</p>
<p><strong>最低为MF，MF=1 表示后面“还有分片”的数据报；MF=0 表示这已是若干数据报片的最后一个。</strong></p>
<p><strong>中间是DF，DF=0 允许分片。</strong></p>
</li>
<li>
<p>片偏移：占13位，指在<strong>原分组中的相对位置，该片从何处开始</strong>。<strong>片偏移以8个字节为偏移单位</strong>。除最后一个数据报片外，其他每个分片的长度一定是 8 字节(64 位)的整数倍。</p>
</li>
<li>
<p>生存时间位：（8位，TTL(Time To Live)）每经过一个路由器时，就把TTL减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒，就把TTL值减1。当TTL值减为零时，就丢弃这个数据报。</p>
</li>
<li>
<p><strong>首部检验和：占16位，只检验数据报的首部，但不包括数据部分</strong>。</p>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231129214842428.png" alt="image-20231129214842428" style="zoom:80%;">
</li>
</ul>
<h1>IP分组转发</h1>
<ul>
<li>从收到的分组的首部提取目的主机的IP地址D(即目的地址)。</li>
<li>若查找到有特定主机路由(目的地址为D)，就按照这条路由的下一跳转发分组，否则从转发表中下一行(也就是前缀最长的一行)开始检查。</li>
<li>把这一行的<strong>子网掩码与目的地址D按位进行AND运算，若运算结果与本行的前缀匹配</strong>，则查找结束，按照“下一跳”所指出的进行处理(或直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器)。</li>
<li>若为没有对应的网络，则使用默认路由，则按照指明的接口，把分组传送到指明的默认路由器，否则，报告转发分组出错。</li>
</ul>
<p>核心就是将目的地址和子网掩码进行AND运算，判断是否是对应的网路前缀，如果是则发送到指定的下一跳。</p>
<p>在和掩码进行AND运算时，可能有多个转发结果，此时需要采用<strong>最长前缀匹配的原则</strong>进行跳转。</p>
<h1>网际控制报文协议ICMP</h1>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231130090900230.png" alt="image-20231130090900230" style="zoom:80%;">
<p>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
<p>ICMP是IP层的协议，作为数据部分封装到IP数据报的数据部分中。</p>
<h2 id="ICMP差错报告报文">ICMP差错报告报文</h2>
<img src="/2023/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20231130091723540.png" alt="image-20231130091723540" style="zoom:80%;">
<p>把收到的需要进行差错报告的 <strong>IP 数据报的首部和数据字段的前8个字节</strong>提取出来，作为 ICMP 报文的数据字段。再加上相应的<strong>ICMP 差错报告报文的前8个字节</strong>，就构成了ICMP 差错报告报文。</p>
<p>提取收到的数据报的数据字段前 8 个字节是为了得到<strong>运输层的端口号</strong>(对于 TCP和UDP)以及<strong>运输层报文的发送序号</strong>。</p>
<p>ICMP差错报告报文共有4种：</p>
<ul>
<li><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li>
<li><strong>时间超过</strong>：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>
<li><strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时就丢弃该数据报，并向源点发送参数问题报文。</li>
<li><strong>改变路由（重定向）</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（找到更好的路由转发）。</li>
</ul>
<p>不发送ICMP报文的几种情况：</p>
<ul>
<li>对ICMP差错报告报文，不再发送ICMP差错报告报文。</li>
<li>对第一个分片的数据报片的所有后续数据报片，都不发送ICMP 差错报告报文。</li>
<li>对具有多播地址的数据报，都不发送ICMP 差错报告报文。</li>
<li>对具有特殊地址(如127.0.0.0 或0.0.0.0)的数据报，不发送ICMP 差错报告报文。</li>
</ul>
<h2 id="ICMP询问报文">ICMP询问报文</h2>
<p>分为两类：</p>
<ul>
<li><strong>回送请求或回送回答</strong>：主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这<br>
种询问报文用来测试目的站是否可达以及了解其有关状态。</li>
<li><strong>时间戳请求或时间戳回答</strong>：在 ICMP 时间戳请求报文发出后，就能够收到对方响应的 ICMP 时间戳回答报文。利用在报文中记录的时间戳(如报文的发送时间和接收时间)，发送方计算出当前网络的往返时延。</li>
</ul>
<h1>路由选择协议</h1>
<h2 id="内部网关协议">内部网关协议</h2>
<h3 id="RIP协议">RIP协议</h3>
<p>基于距离向量的路由选择协议，路由器都要维护从它自己到其他<strong>每一个目的网络的距离记录</strong>。路由器到直接连接的网络的距离定义为 1，从主机到非直接连接的网络的距离定义为所经过的路由器数加1。RIP 允许一条路径<strong>最多只能包含 15个网络</strong>。因此“距离”等于16时即相当于不可达，只<strong>适用于小型互联网</strong>。RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条<strong>具有最少网络数的路由</strong>(即最短路由)。</p>
<h4 id="特点">特点</h4>
<ul>
<li>仅和相邻路由器交换信息，不相邻的路由器不交换信息。</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息，到本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器。</li>
<li>按固定的时间间隔交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。主机虽然也运行协议 RIP，但只被动地接收路由器发来的路由信息。</li>
</ul>
<p>RIP协议就是路由器和<strong>自己相邻的路由器交换路由表信息</strong>，更新保存到本自治网络中所有目的网络的<strong>最短距离</strong>的路由转发<strong>下一跳的位置</strong>。</p>
<h4 id="距离向量算法">距离向量算法</h4>
<p>对每一个相邻路由器发送过来的 RIP 报文，执行以下步骤：</p>
<ol>
<li>对地址为X的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。项目有三个关键数据，即：到目的网络 Net，距离是d，下一跳路由器是X。</li>
<li>对修改后的RIP 报文中的每一个项目，进行以下步骤：
<ol>
<li>若原来的路由表中没有目的网络 Net，则把该项目添加到路由表中。</li>
<li>若原来的路由表有目的网络 Net，则检测下一条是否是 X，如果是则更新为最新的记录，如果不是，则判断距离，更新为距离小的记录，距离相等则不更新。</li>
</ol>
</li>
<li>若三分钟没有收到相邻路由器的更新路由表，则将此相邻路由器即为不可达的路由器，距离设置为16。</li>
</ol>
<p>协议RIP一特点：<strong>好消息传播快、坏消息传播慢</strong>。</p>
<h3 id="OSPF协议">OSPF协议</h3>
<p>开放最短路径优先，使用了最短路径算法 SPF，主要特征是使用链路状态协议。</p>
<h4 id="特点-2">特点</h4>
<ul>
<li>路由器通过所有输出端口向所有相邻路由器发送信息，每个相邻的路由器又将此信息发送到所有的相邻路由器（不在发送刚刚发来消息的那个路由器），采用的泛洪法。</li>
<li>发送消息是本路由器相邻的所有路由器的链路状态，（链路状态是说明本路由器和那些路由器相邻，以及该链路的“度量”）。</li>
<li>当链路状态发生变化或每隔一段时间（30分钟），路由器向所有路由器使用泛洪法发送链路状态信息。</li>
</ul>
<p>各路由器都能建立一个链路状态数据库（全网的拓扑结构图），OSPF协议更新收敛快</p>
<h2 id="外部网关协议">外部网关协议</h2>
<p>BG 是不同自治系统的路由器之间交换路由信息的协议。</p>
<ul>
<li>
<p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” 。</p>
</li>
<li>
<p>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。</p>
</li>
</ul>
<p>BGP发言者之间交换信息。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-运输层</title>
    <url>/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>总结计算机网络运输层知识，主要是TCP和UDP协议特点。</p>
<span id="more"></span>
<h1>运输层协议概述</h1>
<ol>
<li>运输层向上面的应用层提供通信服务。</li>
<li>两台主机进行通信是主机中的应用进程相互通信。</li>
<li>网络层为主机之间的通信提供服务，而运输层在网络层基础上，为应用进程之间的通信提供服务。</li>
<li>TCP协议提供可靠协议，通过差错检测等方式在逻辑上实现，而底层网络层通信时不可靠的。</li>
<li>TCP是逻辑上的一条全双工的可靠通信，UDP协议是不可靠通道。</li>
<li>运输层两个主要协议用户数据报协议UDP和传输控制协议TCP。<strong>UDP传输数据前不需要建立连接，而TCP是提供面向连接的服务</strong>。</li>
</ol>
<table>
<thead>
<tr>
<th>运输层协议</th>
<th>应用层协议</th>
<th style="text-align:center">协议全称</th>
<th>默认端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>HTTP</td>
<td style="text-align:center">HyperText Transfer Protocol（超文本传输协议）</td>
<td>80</td>
</tr>
<tr>
<td>TCP</td>
<td>FTP</td>
<td style="text-align:center">File Transfer Protocol (文件传输协议)</td>
<td>20用于传输数据<br>21用于传输控制信息</td>
</tr>
<tr>
<td>TCP</td>
<td>SMTP</td>
<td style="text-align:center">Simple Mail Transfer Protocol (简单邮件传输协议)</td>
<td>25</td>
</tr>
<tr>
<td>TCP</td>
<td>TELNET</td>
<td style="text-align:center">Teletype over the Network (网络电传)</td>
<td>23</td>
</tr>
<tr>
<td>TCP</td>
<td>SSH</td>
<td style="text-align:center">Secure Shell</td>
<td>22</td>
</tr>
<tr>
<td>UDP</td>
<td>DNS</td>
<td style="text-align:center">Domain Name Service (域名服务)</td>
<td>53</td>
</tr>
<tr>
<td>UDP</td>
<td>TFTP</td>
<td style="text-align:center">Trivial File Transfer Protocol (简单文件传输协议)</td>
<td>69</td>
</tr>
<tr>
<td>UDP</td>
<td>SNMP</td>
<td style="text-align:center">Simple Network Management Protocol (简单网络管理协议)</td>
<td>通过UDP端口161接收<br>只有Trap信息采用UDP端口162</td>
</tr>
<tr>
<td>UDP</td>
<td>NTP</td>
<td style="text-align:center">Network Time Protocol (网络时间协议)</td>
<td>123</td>
</tr>
</tbody>
</table>
<h1>用户数据报协议UDP</h1>
<h2 id="特点">特点</h2>
<ol>
<li>无连接，发送数据前不需要建立连接。</li>
<li>使用尽最大努力交付，不保证可靠交付。</li>
<li>面向报文。UDP一次传送和交付一个完整的报文。</li>
<li>没有拥塞控制。网络出现拥塞不会是源主机的发送速率降低。</li>
<li>支持一对一、一对多、多对一、多对多等交互通信。</li>
<li>首部开销小，只有8个字节。</li>
</ol>
<p>复用：将UDP用户数据报组装成不同的IP数据报，发送到互联网。</p>
<p>分用：根据UDP用户数据报首部中的目的端口号，将数据报分别传送到相应端口，以便应用进到端口读取数据。</p>
<p>分用时，找不到对应的目的端口号，丢弃报文，并给发送方发送ICMP“端口不可达”错误报告报文。</p>
<h2 id="UDP首部格式">UDP首部格式</h2>
<p>UDP数据报两个字段，数据字段和首部字段，首部字段只有8个字节，由4个字段组成，每个字段的长度都是2个字节。</p>
<ul>
<li>源端口：源端口号。</li>
<li>目的端口：目的端口号。</li>
<li>长度：UDP数据报的长度，最小为8（首部）。</li>
<li>检验和：检测UDP用户数据报在传输过程中是否有错，有错就丢弃。</li>
</ul>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231130145409968.png" alt="image-20231130145409968" style="zoom:50%;">
<p>校验和生成：</p>
<ol>
<li>填上伪首部。</li>
<li>全零填充校验和字段。</li>
<li>如果UDP数据报加上伪首部总长度不是2字节的倍数，则全0填充数据部分，补充为2字节的倍数。</li>
<li>伪首部+首部+数据部分采用二进制反码求和。</li>
<li>将和进行求反码填入校验和字段。</li>
</ol>
<p>检验和检验：</p>
<ol>
<li>填上伪首部。</li>
<li>伪首部+首部+数据部分采用二进制反码求和。</li>
<li>结果全为1则无差错，否则对其数据报/交给应用层附上差错警告。</li>
</ol>
<h1>传输控制协议TCP</h1>
<h2 id="特点-2">特点</h2>
<ol>
<li>TCP是<strong>面向连接的运输层协议</strong>，在使用TCP协议之前，必须要建立TCP连接，传输完毕后，释放连接。</li>
<li>TCP是端到端通信（点对点）。</li>
<li>TCP提供<strong>可靠交付</strong>的服务，无差错、不丢失、不重复，并且按序到达。</li>
<li>TCP提供<strong>全双工通信</strong>，TCP连接的两端都设有发送缓存和接收缓存。</li>
<li>TCP是<strong>面向字节流</strong>。把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<h2 id="TCP首部格式">TCP首部格式</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201105345130.png" alt="image-20231201105345130" style="zoom:50%;">
<ul>
<li>
<p>源端口和目的端口：各占两个字节。</p>
</li>
<li>
<p>序号：4个字节，TCP是面向字节流的，序号记录的数据部分第一个字节在原数据的字节序号。</p>
</li>
<li>
<p>确认号：期望收到对方下一个报文段的第一个数据字节的序号。<br>
$$<br>
若确认号=N,则表明:到序号N-1为止的所有数据都已正确收到。<br>
$$</p>
</li>
<li>
<p>数据偏移：指出TCP的首部长度，单位是32位（4字节），数据偏移的最大值是60字节（TCP首部的最大长度），占4位。</p>
</li>
<li>
<p>紧急URG：URG=1，表示紧急指针字段有效，该报文段有紧急数据，具有高优先级，不必再原来排队顺序等待传送。</p>
</li>
<li>
<p>确认ACK：ACK=1时确认号字段才有效，TCP建立建立后所有报文段都必须把ACK置为1。</p>
</li>
<li>
<p>复位RST：TCP连接中出现严重差错，必须释放连接，重新建立运输连接。</p>
</li>
<li>
<p>同步SYN：连接建立用来同步序号，SYN=1而ACK=0，表明这是一个连接请求报文段。</p>
</li>
<li>
<p>终止FIN：释放连接。</p>
</li>
<li>
<p>窗口：窗口值作为接收方让发送方设置其发送窗口的依据。</p>
</li>
<li>
<p>校验和：加上伪首部进行计算校验和，检验范围包括首部和数据两部分，占两个字节。</p>
</li>
</ul>
<h1>停止等待协议</h1>
<ul>
<li>
<p>发送完一个分组就停止发送、等待对方的确认，收到确认后再发送下一个分组。</p>
</li>
<li>
<p>设置超时重传机制。当发送方在超过一定时间未收到接受方发来的确认，则再发送一次该分组。</p>
<p>发送方发送完一个分组后必须要保留已发送分组的副本，超时重传需要再次发送，只有收到相应的确认后才能清除分组副本。</p>
<p>超时重传设置时间比分组传输的平局往返时间更长些，超时重传的时间通过动态计算来更新：<br>
$$<br>
新的RTT_S=(1-\alpha)\times(旧的RTT_S)+\alpha\times(新的RTT样本)<br>
$$</p>
<blockquote>
<p>计算会给出多个RTT样本，每一个都要带入公式计算，而不是样本取平均再带入计算。</p>
<p>如果报文段重传了，就不采用其往返时间样本，不参与计算。</p>
</blockquote>
</li>
</ul>
<p>确认和重传禁止，可以在不可靠的传输网络上实现可靠通信，该协议常称为自动重传请求ARQ。</p>
<p>信道利用率计算：<br>
$$<br>
U=\frac{T_D}{T_D+RTT+T_A}<br>
$$</p>
<ul>
<li>T<sub>D</sub>：发送方发送分组消耗时间。</li>
<li>RTT：数据在信道传输的时间。</li>
<li>T<sub>A</sub>：接收方发送确认分组的时间。</li>
</ul>
<p>连续ARQ协议：</p>
<p>发送方维持一个发送窗口，可一次性发送窗口内的所有分组（流水线），不用一个一个等待确认。接收方采用累计确认的方式，对按序到达的最后一个分组发送确认，通过确认，发送方来移动发送窗口。</p>
<h1>TCP流量控制</h1>
<p>流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。</p>
<p>发送方的发送窗口不能超过接收方给出的接收窗口。</p>
<p>通过TCP首部中窗口值限制发送方的发送窗口大小，来实现流量控制。</p>
<p>TCP为每一个连接设有一个持续计时器，只要TCP连接的乙方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段，接受方收到探测报文段给出现在的窗口值。</p>
<h1>TCP拥塞控制</h1>
<p>拥塞控制时防止过多的数据注入到网络中，时网络中路由器或链路不至于过载，是一个全局性的过程。而流量控制往往是指点对点通行量的控制，是端到端的问题。</p>
<h3 id="慢开始与拥塞避免">慢开始与拥塞避免</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201123429370.png" alt="image-20231201123429370" style="zoom:50%;">
<p>发送方维持一个拥塞窗口，让自己的发送窗口等于拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度，动态变换。</p>
<p>慢开始是发送窗口由小到大逐渐增大拥塞窗口数值，每次两倍增加。同时还要设置慢开始的门限，防止拥塞窗口增长过大引起网络拥塞。</p>
<p>当增大慢开始的门限值，使用拥塞避免算法，成线性缓慢增长。</p>
<blockquote>
<p>当出现网络阻塞，门限值减半，同时拥塞窗口设置为1，执行慢开始算法。</p>
</blockquote>
<h3 id="快重传和快恢复">快重传和快恢复</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201124000551.png" alt="image-20231201124000551" style="zoom:50%;">
<blockquote>
<p>当出线网络阻塞，门限值减半，同时拥塞窗口设置为新的门限值，执行快恢复算法（拥塞串口值线性增长）。</p>
</blockquote>
<p>快重传算法要求接收方不要等待在自己发送数据时才进行捎带确认，而是立即发送确认，即使<strong>收到了失序的报文段也要立即发送对已收到的报文段的重复确认</strong>。</p>
<p>对收到三个连续对分组的确认，则立即重传该分组。</p>
<p>网络阻塞：采用慢开始算法。</p>
<p>三个超时重传确认：采用快重传算法。</p>
<h1>TCP连接管理</h1>
<h2 id="TCP连接">TCP连接</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201130152427.png" alt="image-20231201130152427" style="zoom:50%;">
<p>TCP连接建立采用三次握手机制。</p>
<ul>
<li>第一次：客户端发送连接请求报文，无应用层数据。$SYM=1,seq=x(随机)$。</li>
<li>第二次：服务器为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。$SYN=1,ACK=1,seq=y(随机),ack=x+1$。</li>
<li>第三次：客户端为该TCP连接分配缓存和变量，并向服务器返回确认的确认，可以携带数据。$ACK=1,seq=x+1,ack=y+1$。</li>
</ul>
<p>ack是确认号，seq是报文段的序号。</p>
<h2 id="TCP释放">TCP释放</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/image-20231201130948457.png" alt="image-20231201130948457" style="zoom:50%;">
<p>TCP的连接释放需要4次握手。</p>
<ul>
<li>第一次：客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。$FIN=1,seq=u$。</li>
<li>第二次：服务器返回一个确认报文段，客户到服务器这个方向的连接就释放了，处于半关闭状态。$ACK=1,seq=v,ack=u+1$。</li>
<li>第三次：服务器发送完数据，就发出连接释放报文段，<strong>主动关闭</strong>TCP连接。$FIN=1,ACK=1,seq=w,ack=u+1$。</li>
<li>第四次：客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。$ACK=1,seq=u+1,ack=w+1$</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络章节总复习</title>
    <url>/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>计算机网络期末总复习知识点总结。</p>
<span id="more"></span>
<h1>第 1 章 概述</h1>
<h2 id="1-边缘部分与核心部分">1. 边缘部分与核心部分</h2>
<p>互联网按工作方式可划分为<strong>边缘部分</strong>和<strong>核心部分</strong>。<strong>主机</strong>在网络的边缘，作用是<strong>进行信息处理</strong>。<strong>路由器</strong>在网络的核心部分，其作用是<strong>按存储转发方式进行分组交换</strong>。</p>
<p>边缘部分工作方式：<strong>C/S方式（客户请求服务，服务器提供服务）和P2P方式（对等进行通信）</strong>。</p>
<p>核心部分工作方式：<strong>路由器连接网络，利用存储转发技术转发分组</strong>。</p>
<h2 id="2-分组交换">2. 分组交换</h2>
<p>分组交换采用存储转发技术，把一个报文划分为几个分组（数据段）再进行传送。每个数据段加上必要的控制信息组成首部后，构成已给分组。</p>
<h2 id="3-计算机网络性能指标">3. 计算机网络性能指标</h2>
<ol>
<li>
<p>速率</p>
<p>网络技术中速率指的是数据的传送速率，单位bit/s，即每秒传输多少位。当提到网络的速率，往往指的是额定速率，而并非网络实际运行的速率。</p>
</li>
<li>
<p>带宽</p>
<p>网络带宽是指单位时间内网络的某信道所能通过的“<strong>最高数据率</strong>”，即<strong>数据发送速率上限</strong>。带宽的单位就是数据率的单位bit/s。</p>
</li>
<li>
<p>吞吐量</p>
<p>表示单位时间内通过某个网络的<strong>实际数据量</strong>。</p>
</li>
<li>
<p>时延<br>
$$<br>
总时延=发送时延+传播时延+处理时延+排队时延<br>
$$<br>
发送时延是主机或路由器发送数据帧所需时间：<br>
$$<br>
发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}<br>
$$<br>
传播时延是电磁波在信道中传播一定的距离需要花费的时间：<br>
$$<br>
传播时延=\frac{信道长度(m)}{电磁波在信道上传播速率(m/s)}<br>
$$</p>
</li>
<li>
<p>时延带宽积<br>
$$<br>
时延带宽积=传播时延\times 带宽<br>
$$</p>
</li>
</ol>
<h2 id="4-网络协议">4. 网络协议</h2>
<p>网络协议即协议，是<strong>为了进行网络中数据交换而建立的规则</strong>。<strong>计算机网络的各层及其协议的集合称为网络的体系结构</strong>。</p>
<p>网络协议主要由三部分组成：</p>
<ul>
<li><strong>语法</strong>：数据与控制信息的结构或格式。</li>
<li><strong>语义</strong>：需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li><strong>同步</strong>：事件实现顺序的详细说明。</li>
</ul>
<h2 id="5-五层协议的体系结构">5. 五层协议的体系结构</h2>
<ol>
<li>
<p>应用层</p>
<p>应用层的任务是通过进程之间的交互来完成特定网络应用。应用程协议定义的是<strong>应用进程之间通信和交互的规则</strong>。</p>
<p>应用程协议：DNS、HTTP、SMTP等。应用层交互的数据单元称为<strong>报文</strong>。</p>
</li>
<li>
<p>运输层</p>
<p>运输层任务负责向<strong>两台主机中进程之间</strong>的通信提供<strong>通用的数据传输服务</strong>。</p>
<p>运输层协议：<strong>传输控制协议TCP</strong>，传输单元是<strong>报文段</strong>；用户数据报协议UDP，传输单元是<strong>用户数据报</strong>。</p>
</li>
<li>
<p>网络层</p>
<p>网络层负责为分组交换网上的<strong>不同主机</strong>提供服务。将运输层的数据单元封装成<strong>分组</strong>，也叫<strong>IP数据报</strong>。通过一定算法，生成转发分组的转发表，依据转发表中指明的路径将分组转发到一个路由器中。</p>
</li>
<li>
<p>数据链路层</p>
<p>将<strong>IP数据报</strong>组装成<strong>帧</strong>，每一帧包括数据和必要的控制信息，控制信息使得接收端正确接收帧，对帧尽心差错检测，改正数据。</p>
</li>
<li>
<p>物理层</p>
<p>物理层所传数据的单位是<strong>比特</strong>。</p>
</li>
</ol>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230914095817696.png" alt="image-20230914095817696" style="zoom:80%;">
<h2 id="6-TCP-IP体系结构">6. TCP/IP体系结构</h2>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230914100004924.png" alt="image-20230914100004924" style="zoom:80%;">
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230914100047099.png" alt="image-20230914100047099" style="zoom:80%;">
<h2 id="7-实体、协议、服务和服务访问点">7. 实体、协议、服务和服务访问点</h2>
<ol>
<li>实体：任何可以发送或接收信息的硬件或软件进程。</li>
<li>协议：控制两个对等实体（或多个实体）进行通信的规则的集合。（水平的）</li>
<li>服务：下层向上层通过层间接口提供服务。（垂直的）</li>
<li>服务访问点：同一系统中相邻两层的实体进行交互的地方。</li>
</ol>
<p>协议必须把所有不利的条件事先都要估计到，不能假定一切都是正常的和非常理想的，必须非常仔细地检测协议能否应付任何一种出现概率极小的异常情况。<strong>提高协议面对异常情况的能力</strong>。</p>
<p><strong>协议控制本层向上层提供服务，本层协议的实现要使用下层提供的服务</strong>。</p>
<h1>第 2 章 物理层</h1>
<h2 id="1-物理层任务和特点">1. 物理层任务和特点</h2>
<p>物理层的主要任务是<strong>描述确定与传输媒介的接口有关的特性</strong>：</p>
<ol>
<li><strong>机械特性</strong>：指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的<strong>电压的意义</strong>。</li>
<li><strong>过程特性</strong>：指明对于不同功能的<strong>各种可能事件的出现顺序</strong>。</li>
</ol>
<h2 id="2-通信三种方式">2. 通信三种方式</h2>
<ol>
<li><strong>单工通信</strong>：只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>半双工通信</strong>：通信双方都可以发送消息，当不能双方同时发送或接收。</li>
<li><strong>全双工通信</strong>：通信双方可以同时发送和接收消息。</li>
</ol>
<h2 id="3-规程和协议的区别">3. 规程和协议的区别</h2>
<p>物理层的协议常称为规程，但协议泛指所有层上的协议。</p>
<h2 id="4-数据通信系统模型">4. 数据通信系统模型</h2>
<ol>
<li>
<p><strong>源系统</strong>：包括源点和发送器。</p>
<p>源点：源点设备产生要传输的数据。</p>
<p>发送器：源点生成的数字比特流通过发送器编码后在传输系统中进行传输。</p>
</li>
<li>
<p><strong>传输系统</strong></p>
</li>
<li>
<p><strong>目的系统</strong>：包括接收器和终点。</p>
<p>接收器：接收传输系统传送过来的信号，并转换为能够被目的设备处理的信息。</p>
<p>终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出。</p>
</li>
</ol>
<h2 id="5-基本名称概念">5. 基本名称概念</h2>
<ol>
<li>数据：运送消息的实体。</li>
<li>信号：数据的电气或电磁的表现。</li>
<li>模拟信号：连续信号。</li>
<li>数字信号：离散信号。</li>
<li>码元：代表数字信号不同离散值的基本波形。</li>
<li>基带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li>
<li>带通信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。（<strong>调频，调相，调幅</strong>）</li>
</ol>
<h2 id="6-信道复用技术">6. 信道复用技术</h2>
<ol>
<li>
<p><strong>频分复用</strong></p>
<p>把各路信号分别搬移到适当的频率位置，各路信号在同样时间占用不同的带宽资源。</p>
</li>
<li>
<p><strong>时分复用</strong></p>
<p>每一路信号占用固定序号的时隙，在不同时间占用同样的频带宽度。</p>
<p><strong>统计时分复用（STDM）</strong>：不固定分配时序，而是按需动态分配时隙。</p>
</li>
<li>
<p><strong>波分复用</strong></p>
<p>光的频分复用。</p>
</li>
<li>
<p><strong>码分复用</strong></p>
<p><strong>码分多址（CDMA）</strong>：用户同样的时间使用同样的频带进行通信，各用户使用不同码型，各用户之间不会造成干扰。</p>
<p><strong>码片</strong></p>
<ol>
<li>
<p>每一站有自己的唯一的一个码片序列，发送比特1，则发送它的 m bit码片序列，发送比特0，则发送该码片序列的反码。这个码片序列和其他任何一个站的码片序列向量积为 0。</p>
</li>
<li>
<p>每一个站有其他站的码片向量（码片序列），每个站点接收的信息是其他所有站发送的码片序列之和。</p>
</li>
<li>
<p>码片序列之和和站点拥有的其他站点码片序列依次进行规格化内积运算。如果规格化内积为1或-1，表示是对应站点发送了信息；如果是0，则对应站点没有发送信息。</p>
</li>
<li>
<p>规格化内积为1表示数据信息为比特1，如果是-1，表示为比特0。</p>
</li>
</ol>
</li>
</ol>
<h2 id="7-常用编码方式">7. 常用编码方式</h2>
<ol>
<li>不归零制：正<strong>电平</strong>代表 1，负电平代表 0。（有弱电流影响）</li>
<li>归零制：正<strong>脉冲</strong>代表 1，负脉冲代表0。</li>
<li>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。可以反过来定义。</li>
<li>差分曼彻斯特编码：在每一位的中心始终有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1。</li>
</ol>
<h2 id="8-传输媒介">8. 传输媒介</h2>
<ol>
<li>
<p>导引型传输媒介</p>
<p>双绞线：无屏蔽双绞线、有屏蔽双绞线；3类线、5类线。</p>
<p>同轴电缆：粗轴和细轴。</p>
<p>光纤：多模和单模（衰耗小）</p>
</li>
<li>
<p>非导引型传输媒介</p>
<p>无线、红外或大气激光。</p>
</li>
</ol>
<h1>第 3 章 数据链路层</h1>
<h2 id="1-数据链路和链路的区别">1. 数据链路和链路的区别</h2>
<ol>
<li>链路是从一个节点到相邻节点的一段<strong>物理线路</strong>，中间没有其他交换节点。</li>
<li>数据链路需要有一条物理线路，还必须有一些必要的通信协议控制数据传输。</li>
</ol>
<h2 id="2-数据链路层三个基本问题">2. 数据链路层三个基本问题</h2>
<h3 id="封装成帧">封装成帧</h3>
<p>把一段数据的前后分别添加首部和尾部，构成一个帧。首部和尾部的一个重要作用就是<strong>帧定界</strong>。区分分组的<strong>控制域和数据域</strong>，同时方便对数据进行差错检测。</p>
<h3 id="透明传输">透明传输</h3>
<p>帧开始和结束的标记使用专门的控制字符，为了避免传输数据部分出现的这些特殊字符干扰帧定界，通过某些处理方法避免错误识别发生。</p>
<p>一般有<strong>字节填充、字符填充</strong>（类似于转义字符）和<strong>零比特填充法</strong>（连续5个1出现则后面填充一个0）。</p>
<h3 id="差错检测">差错检测</h3>
<p>帧在传输过程中可能出现<strong>比特差错</strong>的问题。通过校验码或纠正码来对数据进行检测判断，保证数据争取传输。</p>
<p>采用<strong>循环冗余检测码CRC</strong>的检错技术。</p>
<p>循环冗余检测码的原理：给定一个<code>n+1</code>位除数，传输的原始数据后面补充<code>n</code>位0，然后开始做除法（二进制的除法是异或运算），最后计算出的<code>n</code>位余数（<strong>帧检验序列FCS</strong>）填充到之前<code>n</code>位0比特的位置，构成最后传给接受方的数据。接收方接收到发送的数据，用规定好的除数对数据进行验证，如果最终余数验证为0，则说明数据包没有出错。</p>
<h2 id="3-PPP协议">3. PPP协议</h2>
<p>点对点协议PPP是数据链路层使用最多的协议，特点是：简单，只检验差错，不纠正错误，不使用序号，也不进行流量控制，可同时支持多种网络层协议。</p>
<p>PPP协议不支持多点线路（一个主站轮流和链路上的多个站点进行通信），只支持点对点的链路通信。PPP协议只支持全双工通信。</p>
<p><strong>PPP协议组成</strong>：</p>
<ol>
<li>一个将IP数据报封装到串行链路的方法。</li>
<li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议LCP</strong>。</li>
<li>一套<strong>网络控制协议NCP</strong>，其中每一个协议支持不同的网络层协议。</li>
</ol>
<h3 id="PPP帧格式">PPP帧格式</h3>
<p><strong>PPP帧的首部和尾部分别为四个字段（6个字节）和两个字段（3个字节）</strong>。</p>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230926210550132.png" alt="image-20230926210550132" style="zoom:80%;">
<ol>
<li><code>F</code>：字段<code>7E</code>标志一个帧的开始和结束，帧的定界符。</li>
<li><code>A</code>和<code>C</code>：暂时没有进行定义来使用。</li>
</ol>
<p><strong>字节填充</strong></p>
<p>信息段的<code>7E</code>转变为<code>7D 5E</code>，信息字段的<code>7D</code>转化为<code>7D 5D</code>。</p>
<p><strong>零比特填充</strong></p>
<p>信息段每遇到5个连续的1就在后面插入1个0。</p>
<h3 id="PPP协议工作状态">PPP协议工作状态</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230926212309993.png" alt="image-20230926212309993" style="zoom:80%;">
<p>PPP协议共有6中工作状态：①链路静止，②链路建立，③鉴别，④网络层协议，⑤链路打开，⑥链路终止。</p>
<ol>
<li>
<p>用户个人电脑通过解调器呼叫路由器，双方建立物理连接，进入<strong>链路建立</strong>状态。</p>
</li>
<li>
<p>向链路另一端发送LCP的配置请求帧，经过双方协商后，建立LCP链路，进入<strong>鉴别</strong>状态。</p>
</li>
<li>
<p>向链路另一端发送鉴别的信息，若鉴别成功则进入<strong>网络协议状态</strong>，鉴别失败则进入<strong>链路终止</strong>状态。</p>
</li>
<li>
<p>网络协议状态，配置网络层协议，<strong>PPP链路两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组</strong>，配置完毕进入<strong>链路打开</strong>状态。</p>
</li>
<li>
<p>链路打开状态，PPP链路两端可以彼此发送分组。</p>
</li>
<li>
<p>数据传输结束后，链路一段发出终止请求，另一端收到终止确认，转到<strong>链路终止状态</strong>。</p>
</li>
<li>
<p>链路过程出现故障，也会从链路打开转到<strong>链路终止状态</strong>。</p>
</li>
<li>
<p>调制解调器的载波停止后，回到<strong>链路静止状态</strong>。</p>
</li>
</ol>
<h2 id="4-局域网">4. 局域网</h2>
<p>局域网的主要特点：<strong>网络为一个单位所拥有，且地理范围和站点数据均有限</strong>。</p>
<p>局域网的优点：</p>
<ol>
<li>具有广播功能，一个站点可以访问全网，局域网上主机之间共享各种硬件和软件资源。</li>
<li>便于系统的扩展和逐渐演变，各设备位置可灵活调制和改变。</li>
<li>提高系统的可靠性、可用性和生存性。</li>
</ol>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230927093105687.png" alt="image-20230927093105687" style="zoom:80%;">
<h2 id="5-共享媒体资源">5. 共享媒体资源</h2>
<ol>
<li>
<p>静态划分信道</p>
<p>频分复用，时分复用、码分复用等，划分信道代价高，不适用于局域网。</p>
</li>
<li>
<p>动态媒体接入控制</p>
<ul>
<li>随机接入：所有用户可随机地发送信息，但如果多用户同时发送消息，发送碰撞导致发送失败。</li>
<li>受控接入：必须服从一定地控制。分散控制地令牌局域网和集中控制地多点线路探寻。</li>
</ul>
</li>
</ol>
<h2 id="6-以太网">6. 以太网</h2>
<p>传统以太网：DIX Ethernet V2 标准的局域网。</p>
<p>以太网两个主要标准：DIX Ethernet V2标准和 IEEE 的 802.3 标准。</p>
<p>以太网通信采取两种措施：</p>
<ol>
<li><strong>无连接</strong>工作方式，不建立连接直接发送数据，对数据帧<strong>不进行编号</strong>，<strong>不要求对方发回确认</strong>。目的站接收到有差错的帧<strong>直接丢弃</strong>，其他什么都不做。</li>
<li>使用<strong>CSMA/CD协议</strong>，<strong>载波监听多点接入/碰撞检测</strong>。</li>
</ol>
<h2 id="7-适配器">7. 适配器</h2>
<p>计算机与外界局域网通信要通过适配器，又称为网络接口卡或网卡，<strong>计算机的硬件地址就是在适配器的ROM中</strong>。</p>
<p>适配器要进行数据串行传输和并行传输的转换，装有数据缓存的存储芯片，对数据帧进行差错检验后交给网络层。</p>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230927095008113.png" alt="image-20230927095008113" style="zoom:80%;">
<p>适配器有<strong>过滤</strong>功能：只接<strong>收单播帧、广播帧或多播帧</strong>。</p>
<p>适配器的<strong>混杂方式</strong>接收所有以太网上的帧。</p>
<h2 id="8-CSMA-CD协议">8. CSMA/CD协议</h2>
<ol>
<li><strong>多点接入</strong>：许多计算机以多点接入的方式连接在一根总线上。</li>
<li><strong>载波监听</strong>：边发送边监听。</li>
<li><strong>碰撞检测</strong>：适配器边发送数据边检测信道上的信号电压的变化情况，发送碰撞，总线上的信号电压变化幅度会增大（相互叠加）。</li>
</ol>
<p>一旦发送碰撞，就立即停止发送，按照退避算法等待一段随机时间后再次发送。</p>
<p>使用CSMA/CD协议，一个站<strong>不能同时发送消息和接收消息</strong>，<strong>只支持半双工通信</strong>。</p>
<p>假定端到端的传播时延即为$\tau$，最长经过$2\tau$的时间（<strong>争用期 $51.2\mu s$ 512比特时间</strong>）检测出发送碰撞。发送的数据帧不少于64个字节。</p>
<h2 id="9-集线器">9. 集线器</h2>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用CSMA/CD协议，同一时刻至多只允许一个站发送数据。</p>
<p><strong>在物理上是星形网，在逻辑上则是总线型。集线器工作在物理层上，每个端口只负责转发比特，不进行碰撞检测</strong>。</p>
<h2 id="10-MAC地址">10. MAC地址</h2>
<p><strong>硬件地址</strong>又称<strong>物理地址</strong>或<strong>MAC地址</strong>，固化在适配器的ROM中的地址。每个适配器的地址都不相同，48位长。</p>
<h3 id="MAC帧格式">MAC帧格式</h3>
<img src="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230928092329319.png" alt="image-20230928092329319" style="zoom:80%;">
<ul>
<li>类型字段：用来标识上一层使用的是什么协议。</li>
<li>FCS帧检验序列：检查范围是整个的MAC帧，从目的地址开始到FCS为止的五个阶段，不包括物理层插入的8字节的前同步码和帧开始定界符。</li>
<li>多插入的8个字节：前7个字节是接收端的适配器接收MAC帧时能够迅速调整其时间频率，使得时钟同步，最后1个字节是帧开始定界符。</li>
</ul>
<h2 id="11-以太网集线器和交换机带宽计算">11. 以太网集线器和交换机带宽计算</h2>
<ul>
<li>集线器：连接在集线器的站点之间共享集线器的带宽，<strong>集线器带宽平均分配给每个站点</strong>。</li>
<li>交换机：连接交换机每个站点可以同时进行发送和接口操作，（多端口网桥，全双工方式），每个站点的带宽就是交换机上的最大带宽。</li>
</ul>
<h2 id="12-以太网交换机自学习">12. 以太网交换机自学习</h2>
<ol>
<li>主机发送请求，会经过若干个路由器，路由器中有CAM表，记录每个主机的转发接口和MAC地址。如果发送一个请求，CAM表中没有该主机的转发接口和MAC地址等信息，则会记录学习。</li>
<li>在通过路由器进行转发时，会从CAM表中找目的主机的转发接口来进行数据包的转发。</li>
<li>如果目标主机地址找不到，路由器会指向广播操作，向所有转发接口进行数据转发（除了传输了该数据的转发接口）。</li>
<li>通过广播操作，期待接收目标主机发回响应，返回确认给源主机。</li>
</ol>
<h1>第 4 章 网络层</h1>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>期末考试</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度算法</title>
    <url>/2023/11/26/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>介绍一些进程调度上判断依据的概念和计算方式以及进程调度算法的说明。</p>
<span id="more"></span>
<h1>基本概念</h1>
<ul>
<li>
<p>完成时间：进程完成的时间。</p>
</li>
<li>
<p>周转时间：指进程从到达等待队列到完成执行的时间。<br>
$$<br>
T_i=作业i完成时间-作业i到达时间 \quad or \quad T_i=作业i执行时间+作业i等待时间<br>
$$</p>
</li>
<li>
<p>带权周转时间<br>
$$<br>
带权周转时间=\frac{周转时间}{实际执行时间}<br>
$$</p>
</li>
<li>
<p>平均周转时间<br>
$$<br>
平均周转时间=\frac{\sum_{i=1}^{n}作业_i周转时间}{n}<br>
$$</p>
</li>
<li>
<p>平均带权周转时间<br>
$$<br>
平均带权周转时间=\frac{\sum_{i=1}^{n}带权周转时间}{n}<br>
$$</p>
</li>
</ul>
<h1>调度算法</h1>
<h2 id="先来先服务调度算法">先来先服务调度算法</h2>
<ul>
<li>
<p>最简单的调度算法，先进入的队列的进程优先调度</p>
</li>
<li>
<p>非抢占式算法</p>
</li>
</ul>
<h2 id="短作业优先调度算法">短作业优先调度算法</h2>
<ul>
<li>每一次调度从预估运行时间最小的进程优先调度</li>
<li>非抢占式调度算法</li>
<li>和先来先服务调度算法相比，降低平局周转时间和平局带权周转时间</li>
<li>但是存在进程&quot;饿死&quot;问题，即一直有短作业进程进入队列，而长作业进程始终不能被调度</li>
</ul>
<h2 id="时间片轮转调度算法">时间片轮转调度算法</h2>
<ul>
<li>进程按到达系统时间的先后次序排队，按照先来先服务的规则调度进程，但是每个进程在处理机上运行规定好的一个时间片的时间，如果没有执行完，则将进程重新排队到就绪队列队尾。</li>
<li>如果进程在一个时间片上执行等待其他事件发生或资源，则将进程插到阻塞队列中，等所有资源拿到后在插入到就绪队列队尾。</li>
<li>抢占式调度算法。</li>
</ul>
<h2 id="高响应比优先调度算法">高响应比优先调度算法</h2>
<ul>
<li>
<p>非抢占式算法</p>
</li>
<li>
<p>在调度进程的时候统计计算响应比的值，来选择调度哪一个进程，计算公式如下：<br>
$$<br>
R_p=\frac{运行时间+等待时间}{运行时间}<br>
$$<br>
响应比大，优先调度。</p>
</li>
</ul>
<h2 id="优先级调度算法">优先级调度算法</h2>
<ul>
<li>
<p>静态优先级</p>
<p>进程创建时就定义一个优先级，之后整个生命周期优先级不在改变。</p>
<ol>
<li>简单、系统开销小</li>
<li>不灵活，优先级低的长时间得不到调度</li>
</ol>
</li>
<li>
<p>动态优先级</p>
<p>进入系统时根据某种规则赋予一个优先级，其后不断进行动态调整。</p>
<ol>
<li>灵活、资源利用率高</li>
</ol>
</li>
</ul>
<p>优先级调度算法分为抢占式和非抢占式两种。</p>
<p>抢占式指的是只有就绪队列中有比当前运行进程的优先级高的，运行进程被切换下来，运行优先高的进程。</p>
<p>非抢占式指的是当有优先级高的进程在队列中，当前运行的的进程不会切换下来，而是等它执行完。</p>
<p>抢占式适合对实时性要求高的系统，但是会增加系统进程切换的开销。</p>
<p>非抢占式适合批处理系统，只有线程完成或者等待资源才会从处理机上下来。</p>
<h2 id="多级反馈队列调度算法">多级反馈队列调度算法</h2>
<ul>
<li>
<p>有多个就绪队列，每个队列对应一个优先级。每个优先级队列分配的时间片不同，优先级越高，时间片长度越短。</p>
</li>
<li>
<p>新进程进入系统先放入最高优先队列Q1中，执行一个时间片的时间，如果没有执行完，则放入到下一个优先级的队列Q2的队尾。</p>
</li>
<li>
<p>仅当前面优先级高的几个队列为空，才能调度后面较低优先级队列中的进程。</p>
<p>当低优先级队列中进程上处理运行，如果此时高优先级队列中进入新进程，处理机采用抢占式策略，将当前运行进程切换下来，然后运行优先级高队列上的进程。</p>
<p>同优先级队列中的进程按照先来先服务的策略，不进行抢占。</p>
</li>
</ul>
<p>多级反馈队列调度算法能够满足段进程优先处理，系统开销小（长作业进程主要在低优先级队列中进行），能够同时支持分时，实时，批处理的通用操作系统。还是存在较低队列中进程长时间得不到运行，导致&quot;饥饿&quot;。</p>
<h1>解题方法</h1>
<p>对于进程调度求解可以进行画图的形式来做题。例题：</p>
<p><img src="/2023/11/26/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20231127150238829.png" alt="image-20231127150238829"></p>
<img src="/2023/11/26/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20231127151608032.png" alt="image-20231127151608032" style="zoom:70%;">
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>处理机</tag>
      </tags>
  </entry>
</search>
